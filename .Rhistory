# rm(list = ls())
#library(devtools)
install_github("statsmaths/glmgen", subdir="R_pkg/glmgen")
# rm(list = ls())
library(devtools)
# rm(list = ls())
install.packages("devtools")
library(devtools)
install_github("statsmaths/glmgen", subdir="R_pkg/glmgen")
library(glmgen)
library(plotly)
library(tidyverse)
library(extraDistr)
scenario0(500, 5, 0.5, TRUE)
scenario0 <- function(n, d, tau, plots = FALSE) {
# Scenario 0
# g_0 is piecewise constant function alternating between 1 and -1,
# at j + 2 breakpoints
# x drawn randomly from uniform distribution for each component
# f_0 <- a_j * piecewise_function - b_j with b_j such that mean(f_0) = 0
# and a_j such that norm(f_0) = 1
if (length(n) != 1 || length(d) != 1 || length(tau) != 1) {
stop("Scenario function is only suitable for a single scenario.\n
Please ensure inputs are each scalar values.")
}
x_list <- matrix(NA, nrow = d, ncol = n)
y_list <- matrix(NA, nrow = d, ncol = n)
piecewise_constant <- function(x, breakpoints, values) {
intervals <- findInterval(x, breakpoints)
return(values[intervals])
}
for (j in 1:d) {
x_list[j, ] <- runif(n, 0, 1)
# Define breakpoints for piecewise constant function
breakpoints <- seq(0, 1, length.out = j + 2)^2
values <- rep(c(1, -1), length.out = j + 1)  # alternating between 1 and -1
# Piecewise constant function
g_0 <- piecewise_constant(x_list[j, ], breakpoints, values)
b_j <- mean(g_0)
a_j <- 1 / (norm(g_0 - b_j, type = "2") / sqrt(n))
y_list[j, ] <- a_j * g_0 - a_j * b_j
if (plots) {
filename <- paste(getwd(), '/sce0_plot_', j, '.png', sep = '')
png(filename)
plot(y_list[j, ]~x_list[j, ], main = paste('Scenario 0 j =', j), xlab = 'x', ylab = 'y')
dev.off()
}
}
# Sum of each column of y_list
y_star <- colSums(y_list)
# T(3) errors
y <- y_star + rt(n, 3)
y_star_q <- y_star + qt(tau, 3)
if (tau != 0.5) { warning("Tau != 0.5. Only use output for QATF!")}
return(list(x_list, y, y_star_q))
}
scenario0(500, 5, 0.5, TRUE)
scenario0(500, 2, 0.5, TRUE)
breakpoints <- seq(0, 1, length.out = 8)^2
# Define the function using modular math
f <- function(x) {
# Find which interval x belongs to by checking which breakpoint it exceeds
interval <- findInterval(x, breakpoints)
# Alternate between 0 and 1 using modular math
return((interval %% 2) == 1) * 1  # Mod 2 to alternate, multiply by 1 to get 0/1 output
}
# Example usage:
x <- seq(0, 1, by = 0.05)
f(x)
# Example usage:
x <- seq(0, 1, length.out = 100)
plot(f(x)~x)
findInterval(x, breakpoints)
# Define the breakpoints
breakpoints <- seq(0, 1, length.out = 8)^2
# Define the function using modular math
f <- function(x) {
# Find which interval x belongs to, and ensure it stays within the range
interval <- pmin(findInterval(x, breakpoints), length(breakpoints) - 1)
# Alternate between 0 and 1 using modular math
return((interval %% 2) == 1) * 1  # Mod 2 to alternate, multiply by 1 to get 0/1 output
}
# Example usage:
x <- seq(0, 1, length.out = 100)
plot(f(x) ~ x)
# Example usage:
x <- seq(0, 1, length.out = 100)
plot(f(x) ~ x)
beta <- lapply(x, f)
f_bar <- mean(unlist(beta))
beta <- lapply(beta, function(b, adj) b - adj, f_bar)
plot(beta)
beta
plot(unlist(beta))
# Define the function using modular math
f <- function(x) {
breakpoints <- seq(0, 1, length.out = 8)^2
interval <- pmin(findInterval(x, breakpoints), length(breakpoints) - 1)
return((interval %% 2) == 1) * 2  -1
}
# Define the function using modular math
f <- function(x) {
breakpoints <- seq(0, 1, length.out = 8)^2
interval <- pmin(findInterval(x, breakpoints), length(breakpoints) - 1)
return((interval %% 2) == 1) * 2 - 1
}
# Example usage:
x <- seq(0, 1, length.out = 100)
plot(f(x) ~ x)
beta <- lapply(x, f)
f_bar <- mean(unlist(beta))
beta <- lapply(beta, function(b, adj) b - adj, f_bar)
plot(unlist(beta))
# Define the function using modular math
f <- function(x) {
breakpoints <- seq(0, 1, length.out = 8)^2
interval <- pmin(findInterval(x, breakpoints), length(breakpoints) - 1)
return(((interval %% 2) == 1) * 2 - 1)
}
# Example usage:
x <- seq(0, 1, length.out = 100)
plot(f(x) ~ x)
beta <- lapply(x, f)
f_bar <- mean(unlist(beta))
beta <- lapply(beta, function(b, adj) b - adj, f_bar)
plot(unlist(beta))
# Define the function using modular math
f <- function(x) {
breakpoints <- seq(0, 1, length.out = 9)^2
interval <- pmin(findInterval(x, breakpoints), length(breakpoints) - 1)
return(((interval %% 2) == 1) * 2 - 1)
}
# Example usage:
x <- seq(0, 1, length.out = 100)
plot(f(x) ~ x)
beta <- lapply(x, f)
f_bar <- mean(unlist(beta))
beta <- lapply(beta, function(b, adj) b - adj, f_bar)
plot(unlist(beta))
# Define the function using modular math
f <- function(x) {
breakpoints <- seq(0, 1, length.out = 9)^2
interval <- pmin(findInterval(x, breakpoints), length(breakpoints) - 1)
return(((interval %% 2) == 1) * 1)
}
# Example usage:
x <- seq(0, 1, length.out = 100)
plot(f(x) ~ x)
beta <- lapply(x, f)
f_bar <- mean(unlist(beta))
beta <- lapply(beta, function(b, adj) b - adj, f_bar)
plot(unlist(beta))
# Define the function using modular math
f <- function(x) {
ifelse(x <= 0.4, 2.5 * x,
ifelse(x <= 0.6, 45 * x - 17,
ifelse(x <= 0.8, -40 * x + 34,
30 * x - 22)))
}
# Example usage:
x <- seq(0, 1, length.out = 100)
plot(f(x) ~ x)
beta <- lapply(x, f)
f_bar <- mean(unlist(beta))
beta <- lapply(beta, function(b, adj) b - adj, f_bar)
plot(unlist(beta))
dotPlot?
?dotPlot
dotPlot
?dotplot
plot
?plot
?Plot
?dotPlot
?dotchart
X <- cbind(rep(1, 8),
rep(c(-1, 1), 4),
rep(c(-1, -1, 1, 1), 2),
c(rep(-1, 4), rep(1, 4)))
X
t(X) %*% X
inv(t(X) %*% X)
inverse(t(X) %*% X)
solve(t(X) %*% X)
solve(t(X) %*% X)%*%X
solve(t(X) %*% X) %*% t(X)
t(X)
X
X <- cbind(rep(1, 8),
rep(c(-1, 1), 4),
rep(c(-1, -1, 1, 1), 2),
c(rep(-1, 4), rep(1, 4)))
X
rbind(X, X[, 2]*X[, 3], X[, 2]*X[, 4], X[, 3]*X[, 4])
X[, 2]*X[, 3]
X
cbind(X, X[, 2]*X[, 3], X[, 2]*X[, 4], X[, 3]*X[, 4])
Xb <- cbind(X, X[, 2]*X[, 3], X[, 2]*X[, 4], X[, 3]*X[, 4])
Xb
solve(t(Xb) %*% Xb) %*% t(Xb)
solve(t(Xb) %*% Xb)
t(Xb)
Xd <- cbind(Xb, X[, 2]*X[, 3]*X[, 4])
Xd
solve(t(Xd) %*% Xd)
t(Xd)
setwd("~/Desktop/Research/MRDPG/CPDmrdpg")
###########################
# Manual Refinement Check #
# Manual  Interval  Check #
###########################
load("data/seq10n50s3b.RData") # Scenario 1 with node 50
# true_CP <- c(40, 60) # Sce 1, 5
true_CP <- c(50,100) # Sce 2, 6*, 8*
# true_CP <- c(50,100,150,200,250) # Sce 3
true_CP <- c(20, 60, 80, 160, 180) #Sce 3b
dim(A.all_seq) # 10 150  50  50   4
num_seq <- dim(A.all_seq)[1] # 10 sequences
num_T <- dim(A.all_seq)[2] # 150 time points
num_node <- dim(A.all_seq)[3]
num_layer <- dim(A.all_seq)[5]
hat.rank <- c(15, 15, num_layer) # needed for model selection (Question: should be used as input to some FUNC)
A.tensor.even <- A.all_seq[1, seq(2, num_T, by = 2), , , ]
B.tensor.odd  <- A.all_seq[1, seq(1, num_T-1, by = 2), , , ]
source("CI.R")
loc <- c(22, 60, 88, 164, 178)
nu <- refinement1(loc/2, A.tensor.even, B.tensor.odd, rank = c(15, 15, num_layer))
library(rTensor)
source("SBS.R")
source("CUSUM.R")
source("model_selection.R")
source("eval.R")
loc <- c(22, 60, 88, 164, 178)
nu <- refinement1(loc/2, A.tensor.even, B.tensor.odd, rank = c(15, 15, num_layer))
loc <- c(22, 60, 88, 164, 178)
nu <- refinement1(loc/2, A.tensor.even, B.tensor.odd, rank = c(15, 15, num_layer))
intervals <- construct_intervals(0.05, nu, A.tensor.even, B.tensor.odd, rank = c(15, 15, num_layer), TRUE)
nu <- refinement1(loc/2, A.tensor.even, B.tensor.odd, rank = c(15, 15, num_layer))
intervals <- construct_intervals(0.05, nu, A.tensor.even, B.tensor.odd, rank = c(15, 15, num_layer), TRUE)
intervals <- construct_intervals(0.05, nu, A.tensor.even, B.tensor.odd, rank = c(15, 15, num_layer), verbose = TRUE)
source("CI.R")
intervals <- construct_intervals(0.05, nu, A.tensor.even, B.tensor.odd, rank = c(15, 15, num_layer), verbose = TRUE)
