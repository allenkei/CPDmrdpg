probability_2 = sbm_params[[2]]
for(t_iter in 1:50) A.tensor[t_iter,,,] <- generate_tensor_probability_directed(n_1=50, n_2=50, L=4, probability_1)
for(t_iter in 51:100) A.tensor[t_iter,,,] <- generate_tensor_probability_directed(n_1=50, n_2=50, L=4, probability_2)
for(t_iter in 101:150) A.tensor[t_iter,,,] <- generate_tensor_probability_directed(n_1=50, n_2=50, L=4, probability_1)
# for(t_iter in 1:80) A.tensor[t_iter,,,] <- generate_tensor_probability_directed(n_1=50, n_2=50, L=4, probability_1)
# for(t_iter in 81:150) A.tensor[t_iter,,,] <- generate_tensor_probability_directed(n_1=50, n_2=50, L=4, probability_2)
hat.rank <- c(15, 15, 15)
s <- 0
e <- 150
frobenius_holder <- numeric(149)
for(t in 2:148){
frobenius_holder[t] <- CUSUM_frob_SBS(A.tensor, s, e, t, hat.rank)
}
A.tensor.even <- A.tensor[seq(2, 150, by = 2), , , ]
B.tensor.odd  <- A.tensor[seq(1, 149, by = 2), , , ]
if (dim(A.tensor.even)[1] != dim(B.tensor.odd)[1]) {
stop("Make sure even and odd have same length")
}
hat.rank <- c(15, 15, 15)
s <- 0
e <- 75
frobenius_holder <- numeric(74)
for(t in 2:73){
frobenius_holder[t] <- CUSUM_step1(A.tensor.even, s, e, t, obj.B = B.tensor.odd)
}
plot(1:74, frobenius_holder, type='l')
intervals <- construct_intervals(75, sqrt(1/2), 2)
results_one <- cusum_on_intervals(CUSUM_step1, A.tensor.even, c(30, 38), obj.B = B.tensor.odd)
results_all_step1 <- cusum_on_intervals(CUSUM_step1, A.tensor.even, intervals, obj.B = B.tensor.odd)
source("utility.R")
# Kyle's guess for best method
# Thresholding with 20 changepoints
# Elbow method via kneedle: https://ieeexplore.ieee.org/document/5961514
init <- seeded_binary_seg(CUSUM_step1, A.tensor.even, 75, CUSUM_res = results_all_step1,
threshold = 0, method = "Greedy", obj.B = B.tensor.odd)
max <-max(init[[1]]$results[, 2])
init[[2]]$results[, 2]
threshold_list = c(max + 1, init[[2]]$results[, 2][1:20])
results_ms <- seeded_binary_seg(CUSUM_step1, A.tensor.even, 75, CUSUM_res = results_all_step1,
threshold = threshold_list, method = "Greedy", obj.B = B.tensor.odd)
out <- model_selection(results_ms, A.tensor, method = "elbow", hat.rank = hat.rank)
vals <- out[[4]]
ncps <- out[[5]]
plot(ncps, vals, xlab = "Number of Changepoints", ylab = "Log-Likelihood", main = "Thresholds via Changepoints")
text(ncps, vals, ncps, pos = 1, cex = 0.8)
symbols(length(out[[1]]), out[[2]], circles = 1, add = TRUE, inches = 0.08, fg = "red")
text(length(out[[1]]), out[[2]], "Knee", pos = 3, cex = 0.8, col = "red")
threshold_list <- seq(1, max + 1, length.out=50)
results_ms <- seeded_binary_seg(CUSUM_step1, A.tensor.even, 75, CUSUM_res = results_all_step1,
threshold = threshold_list, method = "Greedy", obj.B = B.tensor.odd)
out <- model_selection(results_ms, A.tensor, method = "elbow", hat.rank = hat.rank)
vals <- unique(out[[4]])
ncps <- unique(out[[5]])
plot(vals, ylab = "Log-Likelihood", main = "Thresholds Equally Spaced")
text(1:length(ncps), vals, ncps, pos = 1, cex = 0.8)
symbols(which(length(out[[1]]) == ncps)[1], out[[2]], circles = 1, add = TRUE, inches = 0.08, fg = "red")
text(which(length(out[[1]]) == ncps)[1], out[[2]], "Knee", pos = 3, cex = 0.8, col = "red")
threshold_list = c(max + 1, init[[2]]$results[, 2][1:20])
results_ms <- seeded_binary_seg(CUSUM_step1, A.tensor.even, 75, CUSUM_res = results_all_step1,
threshold = threshold_list, method = "Greedy", obj.B = B.tensor.odd)
out <- model_selection(results_ms, A.tensor, method = "elbow", hat.rank = hat.rank)
vals <- out[[4]]
ncps <- out[[5]]
plot(ncps, vals, xlab = "Number of Changepoints", ylab = "Log-Likelihood", main = "Thresholds via Changepoints")
text(ncps, vals, ncps, pos = 1, cex = 0.8)
symbols(length(out[[1]]), out[[2]], circles = 1, add = TRUE, inches = 0.08, fg = "red")
text(length(out[[1]]), out[[2]], "Knee", pos = 3, cex = 0.8, col = "red")
################################
# More Model Selection Options #
################################
source("utility.R")
# using utilities/model selection
# Both AIC and BIC prefer fewest (0) changepoints
# New l1 penalty - which requires tuning parameter
init <- seeded_binary_seg(CUSUM_step1, A.tensor.even, 75, CUSUM_res = results_all_step1,
threshold = 0, method = "Greedy", obj.B = B.tensor.odd)
max <-max(init[[1]]$results[, 2])
threshold_list <- exp(seq(1, log(max) + 1, length.out=50))
results_ms <- seeded_binary_seg(CUSUM_step1, A.tensor.even, 75, CUSUM_res = results_all_step1,
threshold = threshold_list, method = "Greedy", obj.B = B.tensor.odd)
# Other elbow options
# Thresholding using Max Gain
threshold_list <- seq(1, max + 1, length.out=50)
results_ms <- seeded_binary_seg(CUSUM_step1, A.tensor.even, 75, CUSUM_res = results_all_step1,
threshold = threshold_list, method = "Greedy", obj.B = B.tensor.odd)
out <- model_selection(results_ms, A.tensor, method = "elbow", hat.rank = hat.rank)
vals <- unique(out[[4]])
ncps <- unique(out[[5]])
plot(vals, ylab = "Log-Likelihood", main = "Thresholds Equally Spaced")
text(1:length(ncps), vals, ncps, pos = 1, cex = 0.8)
symbols(which(length(out[[1]]) == ncps)[1], out[[2]], circles = 1, add = TRUE, inches = 0.08, fg = "red")
text(which(length(out[[1]]) == ncps)[1], out[[2]], "Knee", pos = 3, cex = 0.8, col = "red")
# Thresholding using Max Gain, log spacing
threshold_list <- exp(seq(1, log(max) + 1, length.out=50))
results_ms <- seeded_binary_seg(CUSUM_step1, A.tensor.even, 75, CUSUM_res = results_all_step1,
threshold = threshold_list, method = "Greedy", obj.B = B.tensor.odd)
out <- model_selection(results_ms, A.tensor, method = "elbow", hat.rank = hat.rank)
vals <- unique(out[[4]])
ncps <- unique(out[[5]])
plot(vals, ylab = "Log-Likelihood", main = "Thresholds Log-Spaced")
text(1:length(ncps), vals, ncps, pos = 1, cex = 0.8)
symbols(which(length(out[[1]]) == ncps)[1], out[[2]], circles = 1, add = TRUE, inches = 0.08, fg = "red")
text(which(length(out[[1]]) == ncps)[1], out[[2]], "Knee", pos = 3, cex = 0.8, col = "red")
# Thresholding using Changepoints from Greedy, top 10 Gains
threshold_list = c(max + 1, init[[2]]$results[, 2][1:10])
results_ms <- seeded_binary_seg(CUSUM_step1, A.tensor.even, 75, CUSUM_res = results_all_step1,
threshold = threshold_list, method = "Greedy", obj.B = B.tensor.odd)
out <- model_selection(results_ms, A.tensor, method = "elbow", hat.rank = hat.rank)
vals <- out[[4]]
ncps <- out[[5]]
plot(ncps, vals, xlab = "Number of Changepoints", ylab = "Log-Likelihood", main = "Thresholds via Changepoints")
text(ncps, vals, ncps, pos = 1, cex = 0.8)
symbols(length(out[[1]]), out[[2]], circles = 1, add = TRUE, inches = 0.08, fg = "red")
text(length(out[[1]]), out[[2]], "Knee", pos = 3, cex = 0.8, col = "red")
# Thresholding using Changepoints from Greedy, all
threshold_list = c(max + 1, init[[2]]$results[, 2])
results_ms <- seeded_binary_seg(CUSUM_step1, A.tensor.even, 75, CUSUM_res = results_all_step1,
threshold = threshold_list, method = "Greedy", obj.B = B.tensor.odd)
out <- model_selection(results_ms, A.tensor, method = "elbow", hat.rank = hat.rank)
vals <- out[[4]]
ncps <- out[[5]]
plot(ncps, vals, xlab = "Number of Changepoints", ylab = "Log-Likelihood", main = "Thresholds via Changepoints")
text(ncps, vals, ncps, pos = 1, cex = 0.8)
symbols(length(out[[1]]), out[[2]], circles = 1, add = TRUE, inches = 0.08, fg = "red")
text(length(out[[1]]), out[[2]], "Knee", pos = 3, cex = 0.8, col = "red")
# Thresholding using Max Gain, < 15 Changepoints
threshold_list <- seq(1, max + 1, length.out=50)
results_ms <- seeded_binary_seg(CUSUM_step1, A.tensor.even, 75, CUSUM_res = results_all_step1,
threshold = threshold_list, method = "Greedy", obj.B = B.tensor.odd)
out <- model_selection(results_ms, A.tensor, method = "elbow", hat.rank = hat.rank)
vals <- unique(out[[4]][out[[5]] < 15])
ncps <- unique(out[[5]][out[[5]] < 15])
plot(vals, ylab = "Log-Likelihood", main = "Thresholds Equally Spaced")
mtext("Less than 15 Changepoints", side = 3, line = 0.5, cex = 0.9)
text(1:length(ncps), vals, ncps, pos = 1, cex = 0.8)
# Need to recalculate knee
knee <- kneedle(1:length(ncps), vals, concave = FALSE, decreasing = FALSE)
print(knee)
symbols(knee[1], knee[2], circles = 1, add = TRUE, inches = 0.08, fg = "red")
text(knee[1], knee[2], "Knee", pos = 3, cex = 0.8, col = "red")
# Thresholding using Max Gain, log spacing, < 15 Changepoints
threshold_list <- exp(seq(1, log(max) + 1, length.out=50))
results_ms <- seeded_binary_seg(CUSUM_step1, A.tensor.even, 75, CUSUM_res = results_all_step1,
threshold = threshold_list, method = "Greedy", obj.B = B.tensor.odd)
out <- model_selection(results_ms, A.tensor, method = "elbow", hat.rank = hat.rank)
vals <- unique(out[[4]][out[[5]] < 15])
ncps <- unique(out[[5]][out[[5]] < 15])
plot(vals, ylab = "Log-Likelihood", main = "Thresholds Log-Spaced")
mtext("Less than 15 Changepoints", side = 3, line = 0.5, cex = 0.9)
text(1:length(ncps), vals, ncps, pos = 1, cex = 0.8)
# Need to recalculate knee
knee <- kneedle(1:length(ncps), vals, concave = FALSE, decreasing = FALSE)
print(knee)
symbols(knee[1], knee[2], circles = 1, add = TRUE, inches = 0.08, fg = "red")
text(knee[1], knee[2], "Knee", pos = 3, cex = 0.8, col = "red")
A.tensor <- array(NA, c(150, 50, 50, 4))
sbm_params <- get_sbm_params(n=50, L=4, n_c=c(4, 4), flip_layer=TRUE)
probability_1 = sbm_params[[1]]
probability_2 = sbm_params[[2]]
for(t_iter in 1:50) A.tensor[t_iter,,,] <- generate_tensor_probability_directed(n_1=50, n_2=50, L=4, probability_1)
for(t_iter in 51:100) A.tensor[t_iter,,,] <- generate_tensor_probability_directed(n_1=50, n_2=50, L=4, probability_2)
for(t_iter in 101:150) A.tensor[t_iter,,,] <- generate_tensor_probability_directed(n_1=50, n_2=50, L=4, probability_1)
# for(t_iter in 1:80) A.tensor[t_iter,,,] <- generate_tensor_probability_directed(n_1=50, n_2=50, L=4, probability_1)
# for(t_iter in 81:150) A.tensor[t_iter,,,] <- generate_tensor_probability_directed(n_1=50, n_2=50, L=4, probability_2)
A.tensor.even <- A.tensor[seq(2, 150, by = 2), , , ]
B.tensor.odd  <- A.tensor[seq(1, 149, by = 2), , , ]
if (dim(A.tensor.even)[1] != dim(B.tensor.odd)[1]) {
stop("Make sure even and odd have same length")
}
hat.rank <- c(15, 15, 15)
s <- 0
e <- 75
frobenius_holder <- numeric(74)
for(t in 2:73){
frobenius_holder[t] <- CUSUM_step1(A.tensor.even, s, e, t, obj.B = B.tensor.odd)
}
plot(1:74, frobenius_holder, type='l')
intervals <- construct_intervals(75, sqrt(1/2), 2)
results_one <- cusum_on_intervals(CUSUM_step1, A.tensor.even, c(30, 38), obj.B = B.tensor.odd)
results_all_step1 <- cusum_on_intervals(CUSUM_step1, A.tensor.even, intervals, obj.B = B.tensor.odd)
# Other elbow options
# Thresholding using Max Gain
threshold_list <- seq(1, max + 1, length.out=50)
results_ms <- seeded_binary_seg(CUSUM_step1, A.tensor.even, 75, CUSUM_res = results_all_step1,
threshold = threshold_list, method = "Greedy", obj.B = B.tensor.odd)
out <- model_selection(results_ms, A.tensor, method = "elbow", hat.rank = hat.rank)
vals <- unique(out[[4]])
ncps <- unique(out[[5]])
plot(vals, ylab = "Log-Likelihood", main = "Thresholds Equally Spaced")
text(1:length(ncps), vals, ncps, pos = 1, cex = 0.8)
symbols(which(length(out[[1]]) == ncps)[1], out[[2]], circles = 1, add = TRUE, inches = 0.08, fg = "red")
text(which(length(out[[1]]) == ncps)[1], out[[2]], "Knee", pos = 3, cex = 0.8, col = "red")
source("SBS.R")
source("CUSUM.R")
source("model_selection.R")
source("eval.R")
#library(devtools) # install.packages("devtools")
#install_github("etam4260/kneedle") # install the package "kneedle" via "devtools"
library(kneedle)
dim(A.all_seq) # 10 150  50  50   4
num_seq <- dim(A.all_seq)[1] # 10 sequences
num_T <- dim(A.all_seq)[2] # 150 time points
hat.rank <- c(15, 15, 15) # needed for model selection (Question: should be used as input to some FUNC)
true_CP <- c(50,100)
# construct intervals (FIXED for all sequences)
intervals <- construct_intervals(num_T/2, sqrt(1/2), 2) # half of full time span
seq_iter <- 1 # used to test INSIDE the for-loop
output_holder <- matrix(NA, nrow = num_seq, ncol = 4) # 4 metrics
# report mean of metric for all simulated sequences
for(seq_iter in 1:num_seq){
if(seq_iter == 6) break
A.tensor <- A.all_seq[seq_iter,,,,] # a particular sequence with dim 150  50  50   4
# splitting data in half
A.tensor.even <- A.tensor[seq(2, 150, by = 2), , , ]
B.tensor.odd  <- A.tensor[seq(1, 149, by = 2), , , ] # named as B.tensor
# CUSUM_step1 is a FUNC from CUSUM.R
# obtain CP candidate for each interval
# (Comment: add verbose = TRUE)
results_all_step1 <- cusum_on_intervals(CUSUM_step1, A.tensor.even, intervals, obj.B = B.tensor.odd)
# CUSUM_step1 is a FUNC from CUSUM.R
# obtain initial result for threshold
# (Comment: add verbose = TRUE)
init <- seeded_binary_seg(CUSUM_step1, A.tensor.even, num_T/2, CUSUM_res = results_all_step1,
threshold = 0, method = "Greedy", obj.B = B.tensor.odd)
# construct list of threshold
max <- max(init[[1]]$results[, 2])
threshold_list = c(max + 1, init[[2]]$results[, 2][1:10]) # Maximum number of changepoints
results_ms <- seeded_binary_seg(CUSUM_step1, A.tensor.even, num_T/2, CUSUM_res = results_all_step1,
threshold = threshold_list, method = "Greedy", obj.B = B.tensor.odd)
# Model selection
# Currently, all methods need hat.rank
# (Comment: add verbose = TRUE)
out <- model_selection(results_ms, A.tensor, method = "elbow", hat.rank = hat.rank)
# Visualization
vals <- out[[4]]
ncps <- out[[5]]
plot(ncps, vals, xlab = "Number of Changepoints", ylab = "Log-Likelihood", main = "Thresholds via Changepoints")
text(ncps, vals, ncps, pos = 1, cex = 0.8)
symbols(length(out[[1]]), out[[2]], circles = 1, add = TRUE, inches = 0.08, fg = "red")
text(length(out[[1]]), out[[2]], "Knee", pos = 3, cex = 0.8, col = "red")
metric_list <- eval_CP(true_CP, detected_CP = out[[1]], num_T)
cat("detected CP after model selection:", out[[1]], "\n")
cat("metrics: ",metric_list[[1]], metric_list[[2]], metric_list[[3]], metric_list[[4]])
output_holder[seq_iter ,] <- c(metric_list[[1]], metric_list[[2]], metric_list[[3]], metric_list[[4]])
}
if(seq_iter == 6) break
A.tensor <- A.all_seq[seq_iter,,,,] # a particular sequence with dim 150  50  50   4
# splitting data in half
A.tensor.even <- A.tensor[seq(2, 150, by = 2), , , ]
B.tensor.odd  <- A.tensor[seq(1, 149, by = 2), , , ] # named as B.tensor
# CUSUM_step1 is a FUNC from CUSUM.R
# obtain CP candidate for each interval
# (Comment: add verbose = TRUE)
results_all_step1 <- cusum_on_intervals(CUSUM_step1, A.tensor.even, intervals, obj.B = B.tensor.odd)
dim(A.all_seq) # 10 150  50  50   4
num_seq <- dim(A.all_seq)[1] # 10 sequences
num_T <- dim(A.all_seq)[2] # 150 time points
hat.rank <- c(15, 15, 15) # needed for model selection (Question: should be used as input to some FUNC)
true_CP <- c(50,100)
# construct intervals (FIXED for all sequences)
intervals <- construct_intervals(num_T/2, sqrt(1/2), 2) # half of full time span
seq_iter <- 1 # used to test INSIDE the for-loop
output_holder <- matrix(NA, nrow = num_seq, ncol = 4) # 4 metrics
A.tensor <- A.all_seq[seq_iter,,,,] # a particular sequence with dim 150  50  50   4
# splitting data in half
A.tensor.even <- A.tensor[seq(2, 150, by = 2), , , ]
B.tensor.odd  <- A.tensor[seq(1, 149, by = 2), , , ] # named as B.tensor
# CUSUM_step1 is a FUNC from CUSUM.R
# obtain CP candidate for each interval
# (Comment: add verbose = TRUE)
results_all_step1 <- cusum_on_intervals(CUSUM_step1, A.tensor.even, intervals, obj.B = B.tensor.odd)
A.tensor <- A.all_seq[seq_iter,,,,] # a particular sequence with dim 150  50  50   4
# splitting data in half
A.tensor.even <- A.tensor[seq(2, 150, by = 2), , , ]
B.tensor.odd  <- A.tensor[seq(1, 149, by = 2), , , ] # named as B.tensor
# CUSUM_step1 is a FUNC from CUSUM.R
# obtain CP candidate for each interval
# (Comment: add verbose = TRUE)
results_all_step1 <- cusum_on_intervals(CUSUM_step1, A.tensor.even, intervals, obj.B = B.tensor.odd)
library(rTensor)
source("SBS.R")
source("CUSUM.R")
source("model_selection.R")
source("eval.R")
#library(devtools) # install.packages("devtools")
#install_github("etam4260/kneedle") # install the package "kneedle" via "devtools"
library(kneedle)
num_seq <- dim(A.all_seq)[1] # 10 sequences
num_T <- dim(A.all_seq)[2] # 150 time points
hat.rank <- c(15, 15, 15) # needed for model selection (Question: should be used as input to some FUNC)
true_CP <- c(50,100)
# construct intervals (FIXED for all sequences)
intervals <- construct_intervals(num_T/2, sqrt(1/2), 2) # half of full time span
seq_iter <- 1 # used to test INSIDE the for-loop
output_holder <- matrix(NA, nrow = num_seq, ncol = 4) # 4 metrics
# report mean of metric for all simulated sequences
for(seq_iter in 1:num_seq){
if(seq_iter == 6) break
A.tensor <- A.all_seq[seq_iter,,,,] # a particular sequence with dim 150  50  50   4
# splitting data in half
A.tensor.even <- A.tensor[seq(2, 150, by = 2), , , ]
B.tensor.odd  <- A.tensor[seq(1, 149, by = 2), , , ] # named as B.tensor
# CUSUM_step1 is a FUNC from CUSUM.R
# obtain CP candidate for each interval
# (Comment: add verbose = TRUE)
results_all_step1 <- cusum_on_intervals(CUSUM_step1, A.tensor.even, intervals, obj.B = B.tensor.odd)
# CUSUM_step1 is a FUNC from CUSUM.R
# obtain initial result for threshold
# (Comment: add verbose = TRUE)
init <- seeded_binary_seg(CUSUM_step1, A.tensor.even, num_T/2, CUSUM_res = results_all_step1,
threshold = 0, method = "Greedy", obj.B = B.tensor.odd)
# construct list of threshold
max <- max(init[[1]]$results[, 2])
threshold_list = c(max + 1, init[[2]]$results[, 2][1:10]) # Maximum number of changepoints
results_ms <- seeded_binary_seg(CUSUM_step1, A.tensor.even, num_T/2, CUSUM_res = results_all_step1,
threshold = threshold_list, method = "Greedy", obj.B = B.tensor.odd)
# Model selection
# Currently, all methods need hat.rank
# (Comment: add verbose = TRUE)
out <- model_selection(results_ms, A.tensor, method = "elbow", hat.rank = hat.rank)
# Visualization
vals <- out[[4]]
ncps <- out[[5]]
plot(ncps, vals, xlab = "Number of Changepoints", ylab = "Log-Likelihood", main = "Thresholds via Changepoints")
text(ncps, vals, ncps, pos = 1, cex = 0.8)
symbols(length(out[[1]]), out[[2]], circles = 1, add = TRUE, inches = 0.08, fg = "red")
text(length(out[[1]]), out[[2]], "Knee", pos = 3, cex = 0.8, col = "red")
metric_list <- eval_CP(true_CP, detected_CP = out[[1]], num_T)
cat("detected CP after model selection:", out[[1]], "\n")
cat("metrics: ",metric_list[[1]], metric_list[[2]], metric_list[[3]], metric_list[[4]])
output_holder[seq_iter ,] <- c(metric_list[[1]], metric_list[[2]], metric_list[[3]], metric_list[[4]])
}
# report mean of metric for all simulated sequences
for(seq_iter in 1:num_seq){
if(seq_iter == 6) break
A.tensor <- A.all_seq[seq_iter,,,,] # a particular sequence with dim 150  50  50   4
# splitting data in half
A.tensor.even <- A.tensor[seq(2, 150, by = 2), , , ]
B.tensor.odd  <- A.tensor[seq(1, 149, by = 2), , , ] # named as B.tensor
# CUSUM_step1 is a FUNC from CUSUM.R
# obtain CP candidate for each interval
# (Comment: add verbose = TRUE)
results_all_step1 <- cusum_on_intervals(CUSUM_step1, A.tensor.even, intervals, verbose = FALSE, obj.B = B.tensor.odd)
# CUSUM_step1 is a FUNC from CUSUM.R
# obtain initial result for threshold
# (Comment: add verbose = TRUE)
init <- seeded_binary_seg(CUSUM_step1, A.tensor.even, num_T/2, CUSUM_res = results_all_step1,
threshold = 0, method = "Greedy", verbose = FALSE, obj.B = B.tensor.odd)
# construct list of threshold
max <- max(init[[1]]$results[, 2])
threshold_list = c(max + 1, init[[2]]$results[, 2][1:10]) # Maximum number of changepoints
results_ms <- seeded_binary_seg(CUSUM_step1, A.tensor.even, num_T/2, CUSUM_res = results_all_step1,
threshold = threshold_list, method = "Greedy", verbose = FALSE, obj.B = B.tensor.odd)
# Model selection
# Currently, all methods need hat.rank
# (Comment: add verbose = TRUE)
out <- model_selection(results_ms, A.tensor, method = "elbow", verbose = FALSE, hat.rank = hat.rank)
# Visualization
vals <- out[[4]]
ncps <- out[[5]]
plot(ncps, vals, xlab = "Number of Changepoints", ylab = "Log-Likelihood", main = "Thresholds via Changepoints")
text(ncps, vals, ncps, pos = 1, cex = 0.8)
symbols(length(out[[1]]), out[[2]], circles = 1, add = TRUE, inches = 0.08, fg = "red")
text(length(out[[1]]), out[[2]], "Knee", pos = 3, cex = 0.8, col = "red")
metric_list <- eval_CP(true_CP, detected_CP = out[[1]], num_T)
cat("detected CP after model selection:", out[[1]], "\n")
cat("metrics: ",metric_list[[1]], metric_list[[2]], metric_list[[3]], metric_list[[4]])
output_holder[seq_iter ,] <- c(metric_list[[1]], metric_list[[2]], metric_list[[3]], metric_list[[4]])
}
if(seq_iter == 6) break
A.tensor <- A.all_seq[seq_iter,,,,] # a particular sequence with dim 150  50  50   4
# splitting data in half
A.tensor.even <- A.tensor[seq(2, 150, by = 2), , , ]
B.tensor.odd  <- A.tensor[seq(1, 149, by = 2), , , ] # named as B.tensor
# CUSUM_step1 is a FUNC from CUSUM.R
# obtain CP candidate for each interval
# (Comment: add verbose = TRUE)
results_all_step1 <- cusum_on_intervals(CUSUM_step1, A.tensor.even, intervals, verbose = FALSE, obj.B = B.tensor.odd)
library(rTensor)
source("SBS.R")
source("CUSUM.R")
source("model_selection.R")
source("eval.R")
#library(devtools) # install.packages("devtools")
#install_github("etam4260/kneedle") # install the package "kneedle" via "devtools"
library(kneedle)
dim(A.all_seq) # 10 150  50  50   4
num_seq <- dim(A.all_seq)[1] # 10 sequences
num_T <- dim(A.all_seq)[2] # 150 time points
hat.rank <- c(15, 15, 15) # needed for model selection (Question: should be used as input to some FUNC)
true_CP <- c(50,100)
# construct intervals (FIXED for all sequences)
intervals <- construct_intervals(num_T/2, sqrt(1/2), 2) # half of full time span
seq_iter <- 1 # used to test INSIDE the for-loop
output_holder <- matrix(NA, nrow = num_seq, ncol = 4) # 4 metrics
# report mean of metric for all simulated sequences
for(seq_iter in 1:num_seq){
if(seq_iter == 6) break
A.tensor <- A.all_seq[seq_iter,,,,] # a particular sequence with dim 150  50  50   4
# splitting data in half
A.tensor.even <- A.tensor[seq(2, 150, by = 2), , , ]
B.tensor.odd  <- A.tensor[seq(1, 149, by = 2), , , ] # named as B.tensor
# CUSUM_step1 is a FUNC from CUSUM.R
# obtain CP candidate for each interval
# (Comment: add verbose = TRUE)
results_all_step1 <- cusum_on_intervals(CUSUM_step1, A.tensor.even, intervals, verbose = FALSE, obj.B = B.tensor.odd)
# CUSUM_step1 is a FUNC from CUSUM.R
# obtain initial result for threshold
# (Comment: add verbose = TRUE)
init <- seeded_binary_seg(CUSUM_step1, A.tensor.even, num_T/2, CUSUM_res = results_all_step1,
threshold = 0, method = "Greedy", verbose = FALSE, obj.B = B.tensor.odd)
# construct list of threshold
max <- max(init[[1]]$results[, 2])
threshold_list = c(max + 1, init[[2]]$results[, 2][1:10]) # Maximum number of changepoints
results_ms <- seeded_binary_seg(CUSUM_step1, A.tensor.even, num_T/2, CUSUM_res = results_all_step1,
threshold = threshold_list, method = "Greedy", verbose = FALSE, obj.B = B.tensor.odd)
# Model selection
# Currently, all methods need hat.rank
# (Comment: add verbose = TRUE)
out <- model_selection(results_ms, A.tensor, method = "elbow", verbose = FALSE, hat.rank = hat.rank)
# Visualization
vals <- out[[4]]
ncps <- out[[5]]
plot(ncps, vals, xlab = "Number of Changepoints", ylab = "Log-Likelihood", main = "Thresholds via Changepoints")
text(ncps, vals, ncps, pos = 1, cex = 0.8)
symbols(length(out[[1]]), out[[2]], circles = 1, add = TRUE, inches = 0.08, fg = "red")
text(length(out[[1]]), out[[2]], "Knee", pos = 3, cex = 0.8, col = "red")
metric_list <- eval_CP(true_CP, detected_CP = out[[1]], num_T)
cat("detected CP after model selection:", out[[1]], "\n")
cat("metrics: ",metric_list[[1]], metric_list[[2]], metric_list[[3]], metric_list[[4]])
output_holder[seq_iter ,] <- c(metric_list[[1]], metric_list[[2]], metric_list[[3]], metric_list[[4]])
}
# report mean of metric for all simulated sequences
for(seq_iter in 1:num_seq){
if(seq_iter == 6) break
A.tensor <- A.all_seq[seq_iter,,,,] # a particular sequence with dim 150  50  50   4
# splitting data in half
A.tensor.even <- A.tensor[seq(2, 150, by = 2), , , ]
B.tensor.odd  <- A.tensor[seq(1, 149, by = 2), , , ] # named as B.tensor
# CUSUM_step1 is a FUNC from CUSUM.R
# obtain CP candidate for each interval
# (Comment: add verbose = TRUE)
results_all_step1 <- cusum_on_intervals(CUSUM_step1, A.tensor.even, intervals, verbose = FALSE, obj.B = B.tensor.odd)
# CUSUM_step1 is a FUNC from CUSUM.R
# obtain initial result for threshold
# (Comment: add verbose = TRUE)
init <- seeded_binary_seg(CUSUM_step1, A.tensor.even, num_T/2, CUSUM_res = results_all_step1,
threshold = 0, method = "Greedy", verbose = FALSE, obj.B = B.tensor.odd)
# construct list of threshold
max <- max(init[[1]]$results[, 2])
threshold_list = c(max + 1, init[[2]]$results[, 2][1:10]) # Maximum number of changepoints
results_ms <- seeded_binary_seg(CUSUM_step1, A.tensor.even, num_T/2, CUSUM_res = results_all_step1,
threshold = threshold_list, method = "Greedy", verbose = FALSE, obj.B = B.tensor.odd)
# Model selection
# Currently, all methods need hat.rank
# (Comment: add verbose = TRUE)
out <- model_selection(results_ms, A.tensor, method = "elbow", verbose = TRUE, hat.rank = hat.rank)
# Visualization
vals <- out[[4]]
ncps <- out[[5]]
plot(ncps, vals, xlab = "Number of Changepoints", ylab = "Log-Likelihood", main = "Thresholds via Changepoints")
text(ncps, vals, ncps, pos = 1, cex = 0.8)
symbols(length(out[[1]]), out[[2]], circles = 1, add = TRUE, inches = 0.08, fg = "red")
text(length(out[[1]]), out[[2]], "Knee", pos = 3, cex = 0.8, col = "red")
metric_list <- eval_CP(true_CP, detected_CP = out[[1]], num_T)
cat("detected CP after model selection:", out[[1]], "\n")
cat("metrics: ",metric_list[[1]], metric_list[[2]], metric_list[[3]], metric_list[[4]])
output_holder[seq_iter ,] <- c(metric_list[[1]], metric_list[[2]], metric_list[[3]], metric_list[[4]])
}
# report mean of metric for all simulated sequences
# can suppress print statements with verbose = FALSE (default TRUE)
for(seq_iter in 1:num_seq){
if(seq_iter == 6) break
A.tensor <- A.all_seq[seq_iter,,,,] # a particular sequence with dim 150  50  50   4
# splitting data in half
A.tensor.even <- A.tensor[seq(2, 150, by = 2), , , ]
B.tensor.odd  <- A.tensor[seq(1, 149, by = 2), , , ] # named as B.tensor
# CUSUM_step1 is a FUNC from CUSUM.R
# obtain CP candidate for each interval
# (Comment: add verbose = TRUE)
results_all_step1 <- cusum_on_intervals(CUSUM_step1, A.tensor.even, intervals, verbose = TRUE, obj.B = B.tensor.odd)
# CUSUM_step1 is a FUNC from CUSUM.R
# obtain initial result for threshold
# (Comment: add verbose = TRUE)
init <- seeded_binary_seg(CUSUM_step1, A.tensor.even, num_T/2, CUSUM_res = results_all_step1,
threshold = 0, method = "Greedy", verbose = TRUE, obj.B = B.tensor.odd)
# construct list of threshold
max <- max(init[[1]]$results[, 2])
threshold_list = c(max + 1, init[[2]]$results[, 2][1:10]) # Maximum number of changepoints
results_ms <- seeded_binary_seg(CUSUM_step1, A.tensor.even, num_T/2, CUSUM_res = results_all_step1,
threshold = threshold_list, method = "Greedy", verbose = TRUE, obj.B = B.tensor.odd)
# Model selection
# Currently, all methods need hat.rank
# (Comment: add verbose = TRUE)
out <- model_selection(results_ms, A.tensor, method = "elbow", verbose = TRUE, hat.rank = hat.rank)
# Visualization
vals <- out[[4]]
ncps <- out[[5]]
plot(ncps, vals, xlab = "Number of Changepoints", ylab = "Log-Likelihood", main = "Thresholds via Changepoints")
text(ncps, vals, ncps, pos = 1, cex = 0.8)
symbols(length(out[[1]]), out[[2]], circles = 1, add = TRUE, inches = 0.08, fg = "red")
text(length(out[[1]]), out[[2]], "Knee", pos = 3, cex = 0.8, col = "red")
metric_list <- eval_CP(true_CP, detected_CP = out[[1]], num_T)
cat("detected CP after model selection:", out[[1]], "\n")
cat("metrics: ",metric_list[[1]], metric_list[[2]], metric_list[[3]], metric_list[[4]])
output_holder[seq_iter ,] <- c(metric_list[[1]], metric_list[[2]], metric_list[[3]], metric_list[[4]])
}
source("model_selection.R")
# Model selection
# Currently, all methods need hat.rank
# (Comment: add verbose = TRUE)
out <- model_selection(results_ms, A.tensor, method = "elbow", verbose = TRUE, hat.rank = hat.rank)
