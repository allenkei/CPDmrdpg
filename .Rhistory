solve(t(X) %*% X)%*%X
solve(t(X) %*% X) %*% t(X)
t(X)
X
X <- cbind(rep(1, 8),
rep(c(-1, 1), 4),
rep(c(-1, -1, 1, 1), 2),
c(rep(-1, 4), rep(1, 4)))
X
rbind(X, X[, 2]*X[, 3], X[, 2]*X[, 4], X[, 3]*X[, 4])
X[, 2]*X[, 3]
X
cbind(X, X[, 2]*X[, 3], X[, 2]*X[, 4], X[, 3]*X[, 4])
Xb <- cbind(X, X[, 2]*X[, 3], X[, 2]*X[, 4], X[, 3]*X[, 4])
Xb
solve(t(Xb) %*% Xb) %*% t(Xb)
solve(t(Xb) %*% Xb)
t(Xb)
Xd <- cbind(Xb, X[, 2]*X[, 3]*X[, 4])
Xd
solve(t(Xd) %*% Xd)
t(Xd)
source("utility.R")
set.seed(123)
scenario <- "s8b" ### "s1","s2","s3b","s4","s5","s6b","s7"
setwd("~/Desktop/Research/MRDPG/CPDmrdpg")
source("utility.R")
set.seed(123)
scenario <- "s8b" ### "s1","s2","s3b","s4","s5","s6b","s7"
num_node <- 50 ### 50, 100
num_seq <- 10 ### 50, 100 # 10 is for testing the code
if(scenario == "s1"){
# LAYER FLIPPED
num_time <- 150
num_layer <- 4
num_block_before <- 4 # same
num_block_after <- 4 # same
FL = TRUE # FLIP
}else if(scenario == "s2"){
# BLOCK NUMBER CHANGED
num_time <- 150
num_layer <- 4
num_block_before <- 3 # different
num_block_after <- 4 # different
FL = FALSE # NO FLIP
}else if(scenario == "s3"){
# COMBINE s1 and s2 WITH LONGER TIME SPAN
num_time <- 300 # longer time span
num_layer <- 4
# BLOCK NUMBER K CHANGED
num_block_before_K <- 4 # different
num_block_after_K <- 3 # different
FL_K = FALSE # same
# LAYER L FLIPPED
num_block_before_L <- 4 # same
num_block_after_L <- 4 # same
FL_L = TRUE # different
}else if(scenario == "s3b"){
# COMBINE s1 and s2 WITH LONGER TIME SPAN
num_time <- 200 # longer time span
num_layer <- 4
# BLOCK NUMBER K CHANGED
num_block_before_K <- 4 # different
num_block_after_K <- 3 # different
FL_K = FALSE # same
# LAYER L FLIPPED
num_block_before_L <- 4 # same
num_block_after_L <- 4 # same
FL_L = TRUE # different
}else if(scenario == "s4"){
# NO CHANGED
num_time <- 150
num_layer <- 4
num_block_before <- 4 # same
num_block_after <- 4 # same
FL = FALSE # NO FLIP
}else if(scenario == "s5"){
# VARIED BLOCK SIZES
num_time <- 150
num_layer <- 4
block_size1 <- floor(c(3, 4, 3) / 10 * num_node) # fixed ratio
block_size2 <- floor(c(2, 3, 5) / 10 * num_node) # fixed ratio
block_size3 <- floor(c(4, 3, 3) / 10 * num_node) # fixed ratio
}else if(scenario == "s6"){
# FIRST LAYER DIFFERS
num_time <- 150
num_layer <- 4
block_size1 <- floor(c(3, 4, 3) / 10 * num_node) # fixed ratio
block_size2 <- floor(c(4, 3, 3) / 10 * num_node) # fixed ratio
}else if(scenario == "s6b"){
# FIRST LAYER DIFFERS
num_time <- 150
num_layer <- 4
block_size1 <- floor(c(3, 4, 3) / 10 * num_node) # fixed ratio
block_size2 <- floor(c(5, 2, 3) / 10 * num_node) # fixed ratio
}else if(scenario == "s6.06"){
# .02, .04, .06, .08
# FIRST LAYER DIFFERS
num_time <- 150
num_layer <- 4
epsilon <- 0.6
block_size1 <- floor(c(3, 3+epsilon, 3) / 10 * num_node) # fixed ratio
block_size2 <- floor(c(3+epsilon, 3, 3) / 10 * num_node) # fixed ratio
}else if(scenario == "s7"){
# SEE 'utility.R' FOR DETAILS
# THIS SCENARIO HAS TEMPORAL DEPENDENCY
num_time <- 100
num_layer <- 4
true_CP <- c(20,50,80) # RIGHT NOW, need exactly 3 CPs; no need to be evenly-spaced; see codes
rho <- 0.1 # TEMPORAL DEPENDENCY; can try (0.1, 0.5, 0.9)
}else if(scenario == "s7b"){
# SEE 'utility.R' FOR DETAILS
# THIS SCENARIO HAS TEMPORAL DEPENDENCY
num_time <- 100
num_layer <- 4
true_CP <- c(20,50,80) # RIGHT NOW, need exactly 3 CPs; no need to be evenly-spaced; see codes
rho <- 0.5
}else if(scenario == "s8"){
num_time <- 150
num_layer <- 4
epsilon <- 0.05 # Default 0.1
}else if(scenario == "s8.05"){
num_time <- 150
num_layer <- 4
epsilon <- 0.05
}else if(scenario == "s8b"){
num_time <- 200
num_layer <- 4
epsilon <- 0.05
}
# if(scenario == "s1" | scenario == "s2"){
if(scenario == "s1"){
sbm_params <- get_sbm_params(n=num_node, L=num_layer, n_c=c(num_block_before, num_block_after), flip_layer=FL)
probability_1 = sbm_params[[1]]
probability_2 = sbm_params[[2]]
A.all_seq <- array(NA, c(num_seq, num_time, num_node, num_node, num_layer)) # i.e. 10 sequences empty
# begin simulate data
for(seq_iter in 1:num_seq){
A.tensor <- array(NA, c(num_time, num_node, num_node, num_layer)) # 1 sequence
# T from 1 to 150 (otherwise change the for loop)
for(t_iter in 1:40) A.tensor[t_iter,,,]    <- generate_tensor_probability_directed(n_1=num_node, n_2=num_node, L=num_layer, probability_1)
for(t_iter in 41:60) A.tensor[t_iter,,,]  <- generate_tensor_probability_directed(n_1=num_node, n_2=num_node, L=num_layer, probability_2)
for(t_iter in 61:150) A.tensor[t_iter,,,] <- generate_tensor_probability_directed(n_1=num_node, n_2=num_node, L=num_layer, probability_1)
A.all_seq[seq_iter,,,,] <- A.tensor
}; rm(seq_iter, A.tensor)
dim(A.all_seq)
save(A.all_seq, file = paste0("data/seq",num_seq,"n",num_node,scenario,".RData")) # data folder exists
}else if(scenario == "s2"){
#sbm_params <- get_sbm_params(n=num_node, L=num_layer, n_c=c(num_block_before, num_block_after), flip_layer=FL)
probability_1 = sbm_params[[1]]
probability_2 = sbm_params[[2]]
A.all_seq <- array(NA, c(num_seq, num_time, num_node, num_node, num_layer)) # i.e. 10 sequences empty
# begin simulate data
for(seq_iter in 1:num_seq){
A.tensor <- array(NA, c(num_time, num_node, num_node, num_layer)) # 1 sequence
# T from 1 to 150 (otherwise change the for loop)
for(t_iter in 1:50) A.tensor[t_iter,,,]    <- generate_tensor_probability_directed(n_1=num_node, n_2=num_node, L=num_layer, probability_1)
for(t_iter in 51:100) A.tensor[t_iter,,,]  <- generate_tensor_probability_directed(n_1=num_node, n_2=num_node, L=num_layer, probability_2)
for(t_iter in 101:150) A.tensor[t_iter,,,] <- generate_tensor_probability_directed(n_1=num_node, n_2=num_node, L=num_layer, probability_1)
A.all_seq[seq_iter,,,,] <- A.tensor
}; rm(seq_iter, A.tensor)
dim(A.all_seq)
save(A.all_seq, file = paste0("data/seq",num_seq,"n",num_node,scenario,".RData")) # data folder exists
}else if(scenario == "s3"){
# BLOCK
sbm_params_K <- get_sbm_params(n=num_node, L=num_layer, n_c=c(num_block_before_K, num_block_after_K), FL_K)
probability_K_1 = sbm_params_K[[1]]
probability_K_2 = sbm_params_K[[2]]
# LAYER
sbm_params_L <- get_sbm_params(n=num_node, L=num_layer, n_c=c(num_block_before_L, num_block_after_L), FL_L)
probability_L_1 = sbm_params_L[[1]]
probability_L_2 = sbm_params_L[[2]]
A.all_seq <- array(NA, c(num_seq, num_time, num_node, num_node, num_layer)) # i.e. 10 sequences empty
# begin simulate data
for(seq_iter in 1:num_seq){
A.tensor <- array(NA, c(num_time, num_node, num_node, num_layer)) # 1 sequence
# T from 1 to 300 (otherwise change the for loop)
for(t_iter in 1:50) A.tensor[t_iter,,,]    <- generate_tensor_probability_directed(n_1=num_node, n_2=num_node, L=num_layer, probability_K_1)
for(t_iter in 51:100) A.tensor[t_iter,,,]  <- generate_tensor_probability_directed(n_1=num_node, n_2=num_node, L=num_layer, probability_K_2)
for(t_iter in 101:150) A.tensor[t_iter,,,] <- generate_tensor_probability_directed(n_1=num_node, n_2=num_node, L=num_layer, probability_L_2)
for(t_iter in 151:200) A.tensor[t_iter,,,] <- generate_tensor_probability_directed(n_1=num_node, n_2=num_node, L=num_layer, probability_L_1)
for(t_iter in 201:250) A.tensor[t_iter,,,] <- generate_tensor_probability_directed(n_1=num_node, n_2=num_node, L=num_layer, probability_K_2)
for(t_iter in 251:300) A.tensor[t_iter,,,] <- generate_tensor_probability_directed(n_1=num_node, n_2=num_node, L=num_layer, probability_K_1)
A.all_seq[seq_iter,,,,] <- A.tensor
}; rm(seq_iter, A.tensor)
dim(A.all_seq)
save(A.all_seq, file = paste0("data/seq",num_seq,"n",num_node,scenario,".RData")) # data folder exists
}else if(scenario == "s3b"){
# BLOCK
sbm_params_K <- get_sbm_params(n=num_node, L=num_layer, n_c=c(num_block_before_K, num_block_after_K), FL_K)
probability_K_1 = sbm_params_K[[1]]
probability_K_2 = sbm_params_K[[2]]
# LAYER
sbm_params_L <- get_sbm_params(n=num_node, L=num_layer, n_c=c(num_block_before_L, num_block_after_L), FL_L)
probability_L_1 = sbm_params_L[[1]]
probability_L_2 = sbm_params_L[[2]]
A.all_seq <- array(NA, c(num_seq, num_time, num_node, num_node, num_layer)) # i.e. 10 sequences empty
# begin simulate data
for(seq_iter in 1:num_seq){
A.tensor <- array(NA, c(num_time, num_node, num_node, num_layer)) # 1 sequence
# T from 1 to 300 (otherwise change the for loop)
# for(t_iter in 1:50) A.tensor[t_iter,,,]    <- generate_tensor_probability_directed(n_1=num_node, n_2=num_node, L=num_layer, probability_K_1)
# for(t_iter in 51:100) A.tensor[t_iter,,,]  <- generate_tensor_probability_directed(n_1=num_node, n_2=num_node, L=num_layer, probability_K_2)
# for(t_iter in 101:150) A.tensor[t_iter,,,] <- generate_tensor_probability_directed(n_1=num_node, n_2=num_node, L=num_layer, probability_L_2)
# for(t_iter in 151:200) A.tensor[t_iter,,,] <- generate_tensor_probability_directed(n_1=num_node, n_2=num_node, L=num_layer, probability_L_1)
# for(t_iter in 201:250) A.tensor[t_iter,,,] <- generate_tensor_probability_directed(n_1=num_node, n_2=num_node, L=num_layer, probability_K_2)
# for(t_iter in 251:300) A.tensor[t_iter,,,] <- generate_tensor_probability_directed(n_1=num_node, n_2=num_node, L=num_layer, probability_K_1)
for(t_iter in 1:20) A.tensor[t_iter,,,]    <- generate_tensor_probability_directed(n_1=num_node, n_2=num_node, L=num_layer, probability_K_1)
for(t_iter in 21:60) A.tensor[t_iter,,,]  <- generate_tensor_probability_directed(n_1=num_node, n_2=num_node, L=num_layer, probability_K_2)
for(t_iter in 61:80) A.tensor[t_iter,,,] <- generate_tensor_probability_directed(n_1=num_node, n_2=num_node, L=num_layer, probability_L_2)
for(t_iter in 81:160) A.tensor[t_iter,,,] <- generate_tensor_probability_directed(n_1=num_node, n_2=num_node, L=num_layer, probability_L_1)
for(t_iter in 161:180) A.tensor[t_iter,,,] <- generate_tensor_probability_directed(n_1=num_node, n_2=num_node, L=num_layer, probability_K_2)
for(t_iter in 181:200) A.tensor[t_iter,,,] <- generate_tensor_probability_directed(n_1=num_node, n_2=num_node, L=num_layer, probability_K_1)
# c(20, 60, 80, 160, 180)
A.all_seq[seq_iter,,,,] <- A.tensor
}; rm(seq_iter, A.tensor)
dim(A.all_seq)
save(A.all_seq, file = paste0("data/seq",num_seq,"n",num_node,scenario,".RData")) # data folder exists
}else if(scenario == "s4"){
sbm_params <- get_sbm_params(n=num_node, L=num_layer, n_c=c(num_block_before, num_block_after), flip_layer=FL)
probability_1 = sbm_params[[1]] # ONLY USE THIS
A.all_seq <- array(NA, c(num_seq, num_time, num_node, num_node, num_layer)) # i.e. 10 sequences empty
# begin simulate data
for(seq_iter in 1:num_seq){
A.tensor <- array(NA, c(num_time, num_node, num_node, num_layer)) # 1 sequence
# T from 1 to 150 (otherwise change the for loop)
for(t_iter in 1:150) A.tensor[t_iter,,,]    <- generate_tensor_probability_directed(n_1=num_node, n_2=num_node, L=num_layer, probability_1)
A.all_seq[seq_iter,,,,] <- A.tensor
}; rm(seq_iter, A.tensor)
dim(A.all_seq)
save(A.all_seq, file = paste0("data/seq",num_seq,"n",num_node,scenario,".RData")) # data folder exists
}else if(scenario == "s5"){
sbm_params1 <- get_sbm_var_size_params(n=num_node, L=num_layer, block_size1, block_size2)
sbm_params2 <- get_sbm_var_size_params(n=num_node, L=num_layer, block_size2, block_size3)
probability_1 = sbm_params1[[1]]
probability_2 = sbm_params1[[2]]
probability_3 = sbm_params2[[2]] # the second prob mat from sbm_params2
A.all_seq <- array(NA, c(num_seq, num_time, num_node, num_node, num_layer)) # i.e. 10 sequences empty
# begin simulate data
for(seq_iter in 1:num_seq){
A.tensor <- array(NA, c(num_time, num_node, num_node, num_layer)) # 1 sequence
# T from 1 to 150 (otherwise change the for loop)
for(t_iter in 1:40) A.tensor[t_iter,,,]    <- generate_tensor_probability_directed(n_1=num_node, n_2=num_node, L=num_layer, probability_1)
for(t_iter in 41:60) A.tensor[t_iter,,,]  <- generate_tensor_probability_directed(n_1=num_node, n_2=num_node, L=num_layer, probability_2)
for(t_iter in 61:150) A.tensor[t_iter,,,] <- generate_tensor_probability_directed(n_1=num_node, n_2=num_node, L=num_layer, probability_3)
A.all_seq[seq_iter,,,,] <- A.tensor
}; rm(seq_iter, A.tensor)
dim(A.all_seq)
save(A.all_seq, file = paste0("data/seq",num_seq,"n",num_node,scenario,".RData")) # data folder exists
} else if(startsWith(scenario, "s6")){
sbm_params <- get_sbm_VS_FL_params(n=num_node, L=num_layer, block_size1, block_size2)
probability_1 = sbm_params[[1]]
probability_2 = sbm_params[[2]]
A.all_seq <- array(NA, c(num_seq, num_time, num_node, num_node, num_layer)) # i.e. 10 sequences empty
# begin simulate data
for(seq_iter in 1:num_seq){
A.tensor <- array(NA, c(num_time, num_node, num_node, num_layer)) # 1 sequence
# T from 1 to 150 (otherwise change the for loop)
for(t_iter in 1:50) A.tensor[t_iter,,,]    <- generate_tensor_probability_directed(n_1=num_node, n_2=num_node, L=num_layer, probability_1)
for(t_iter in 51:100) A.tensor[t_iter,,,]  <- generate_tensor_probability_directed(n_1=num_node, n_2=num_node, L=num_layer, probability_2)
for(t_iter in 101:150) A.tensor[t_iter,,,] <- generate_tensor_probability_directed(n_1=num_node, n_2=num_node, L=num_layer, probability_1)
A.all_seq[seq_iter,,,,] <- A.tensor
}; rm(seq_iter, A.tensor)
dim(A.all_seq)
save(A.all_seq, file = paste0("data/seq",num_seq,"n",num_node,scenario,".RData")) # data folder exists
} else if(scenario == "s7" || scenario == "s7b"){
# this function directly output A.all_seq with (num_seq, num_time, n, n, L)
A.all_seq <- sim_SBM_array(num_seq, num_node, rho, num_layer, true_CP, num_time)
dim(A.all_seq)
save(A.all_seq, file = paste0("data/seq",num_seq,"n",num_node,scenario,".RData")) # data folder exists
} else if(scenario == "s8b"){
sbm_params <- get_sbm_params_spa_inc(n=num_node, L=num_layer, epsilon = epsilon)
probability_1 = sbm_params[[1]]
probability_2 = sbm_params[[2]]
probability_3 = sbm_params[[3]]
A.all_seq <- array(NA, c(num_seq, num_time, num_node, num_node, num_layer)) # i.e. 10 sequences empty
# begin simulate data
for(seq_iter in 1:num_seq){
A.tensor <- array(NA, c(num_time, num_node, num_node, num_layer)) # 1 sequence
# T from 1 to 150 (otherwise change the for loop)
for(t_iter in 1:20) A.tensor[t_iter,,,]    <- generate_tensor_probability_directed(n_1=num_node, n_2=num_node, L=num_layer, probability_1)
for(t_iter in 21:60) A.tensor[t_iter,,,]  <- generate_tensor_probability_directed(n_1=num_node, n_2=num_node, L=num_layer, probability_2)
for(t_iter in 61:120) A.tensor[t_iter,,,] <- generate_tensor_probability_directed(n_1=num_node, n_2=num_node, L=num_layer, probability_3)
for(t_iter in 121:150) A.tensor[t_iter,,,] <- generate_tensor_probability_directed(n_1=num_node, n_2=num_node, L=num_layer, probability_2)
for(t_iter in 151:200) A.tensor[t_iter,,,] <- generate_tensor_probability_directed(n_1=num_node, n_2=num_node, L=num_layer, probability_1)
A.all_seq[seq_iter,,,,] <- A.tensor
}; rm(seq_iter, A.tensor)
dim(A.all_seq)
save(A.all_seq, file = paste0("data/seq",num_seq,"n",num_node,scenario,".RData")) # data folder exists
} else if(startsWith(scenario, "s8")) {
sbm_params <- get_sbm_params_spa_inc(n=num_node, L=num_layer, epsilon = epsilon)
probability_1 = sbm_params[[1]]
probability_2 = sbm_params[[2]]
probability_3 = sbm_params[[3]]
A.all_seq <- array(NA, c(num_seq, num_time, num_node, num_node, num_layer)) # i.e. 10 sequences empty
# begin simulate data
for(seq_iter in 1:num_seq){
A.tensor <- array(NA, c(num_time, num_node, num_node, num_layer)) # 1 sequence
# T from 1 to 150 (otherwise change the for loop)
for(t_iter in 1:50) A.tensor[t_iter,,,]    <- generate_tensor_probability_directed(n_1=num_node, n_2=num_node, L=num_layer, probability_1)
for(t_iter in 51:100) A.tensor[t_iter,,,]  <- generate_tensor_probability_directed(n_1=num_node, n_2=num_node, L=num_layer, probability_2)
for(t_iter in 101:150) A.tensor[t_iter,,,] <- generate_tensor_probability_directed(n_1=num_node, n_2=num_node, L=num_layer, probability_3)
A.all_seq[seq_iter,,,,] <- A.tensor
}; rm(seq_iter, A.tensor)
dim(A.all_seq)
save(A.all_seq, file = paste0("data/seq",num_seq,"n",num_node,scenario,".RData")) # data folder exists
}
run_sensitivity <- function(both = TRUE) {
confirm <- function(label) {
repeat {
ans <- readline(paste0("Did you check ", label, "? (y/n): "))
if (tolower(ans) == "y") break
if (tolower(ans) == "n") stop(paste("Please fix ", label, " before proceeding."))
cat("Please answer 'y' or 'n'.\n")
}
}
confirm("true_cp")
confirm("load files for 50 and 100")
confirm("save files for 50 and 100")
cat("All settings confirmed. Proceeding...\n")
# true_CP <- c(40, 60) # Sce 1, 5
# true_CP <- c(50,100) # Sce 2, 6*, 8*
true_CP <- c(20, 60, 120, 150) #Sce 8b
# true_CP <- c(50,100,150,200,250) # Sce 3
# true_CP <- c(20, 60, 80, 160, 180) #Sce 3b
# true_CP <- c() # Sce 4
# true_CP <- c(20,50,80) # Sce 7
load("data/seq10n50s8b.RData") # Scenario 1 with node 50
# Generate data 0
num_seq <- dim(A.all_seq)[1] # 10 sequences
num_T <- dim(A.all_seq)[2] # 150 time points
num_node <- dim(A.all_seq)[3]
num_layer <- dim(A.all_seq)[5]
hat.rank <- c(15, 15, num_layer) # needed for model selection (Question: should be used as input to some FUNC)
# c(0.1, 0.2, 0.25, 0.3, 0.4)
# c(0.05, 0.1, 0.15, 0.2, 0.3, 0.4, 0.5, 0.7, 0.9)
threshold_list <- rev(c(0.05, 0.1, 0.15, 0.2, 0.25, 0.3) * num_node*sqrt(num_layer)*(log(num_T/2))^(3/2))
seq_iter <- 1 # used to test INSIDE the for-loop
intervals <- construct_intervals(num_T/2, sqrt(1/2), 4)
output_holder_g <- array(NA, dim = c(num_seq, length(threshold_list), 4))
output_holder_gl1 <- array(NA, dim = c(num_seq, length(threshold_list), 4))
# report mean of metric for all simulated sequences
# can suppress print statements with verbose = FALSE (default TRUE)
for(seq_iter in 1:num_seq) {
# Generate data 1 by 1
cat("\nIteration", seq_iter, "begin.\n")
A.tensor <- A.all_seq[seq_iter,,,,] # a particular sequence with dim 150  50  50   4
# splitting data in half
A.tensor.even <- A.tensor[seq(2, num_T, by = 2), , , ]
B.tensor.odd  <- A.tensor[seq(1, num_T-1, by = 2), , , ] # named as B.tensor
gains <- cusum_on_intervals(CUSUM_step1, A.tensor.even, verbose = FALSE, intervals, obj.B = B.tensor.odd)
results_g <- seeded_binary_seg(CUSUM_step1, A.tensor.even, num_T/2, CUSUM_res = gains, verbose = FALSE,
threshold = threshold_list, method = "Greedy", obj.B = B.tensor.odd)
for (i in 1:(length(results_g)-1)) {
detected_CP_g <- sort(results_g[[i+1]]$results[, 1])
detected_CP_gl1 <- refinement1(detected_CP_g, A.tensor.even, B.tensor.odd, hat.rank)
output_holder_g[seq_iter, i, ] <- as.numeric(eval_CP(true_CP, 2*detected_CP_g, num_T))
output_holder_gl1[seq_iter, i, ] <- as.numeric(eval_CP(true_CP, 2*detected_CP_gl1, num_T))
cat("Threshold: ", threshold_list[i], "\n")
cat("\tDetected Greedy CP  :", 2*detected_CP_g, ". Metrics: ", output_holder_g[seq_iter, i, ], "\n")
cat("\tRefinement Greedy   :", 2*detected_CP_gl1, ". Metrics: ", output_holder_gl1[seq_iter, i, ], "\n")
}
}
sce_50 <- list(
greedy = output_holder_g,
greedyl1 = output_holder_gl1
)
save(sce_50, file = "results/sce8b_50.RData")
if(both == FALSE) {return ()}
load("data/seq10n100s6.RData") # Scenario 1 with node 100
num_seq <- dim(A.all_seq)[1] # 10 sequences
num_T <- dim(A.all_seq)[2] # 150 time points
num_node <- dim(A.all_seq)[3]
num_layer <- dim(A.all_seq)[5]
hat.rank <- c(15, 15, num_layer) # needed for model selection (Question: should be used as input to some FUNC)
threshold_list <- rev(c(0.05, 0.1, 0.15, 0.2, 0.3, 0.4, 0.5, 0.7, 0.9) * num_node*sqrt(num_layer)*(log(num_T/2))^(3/2))
seq_iter <- 1 # used to test INSIDE the for-loop
intervals <- construct_intervals(num_T/2, sqrt(1/2), 4)
output_holder_g <- array(NA, dim = c(num_seq, length(threshold_list), 4))
output_holder_gl1 <- array(NA, dim = c(num_seq, length(threshold_list), 4))
# report mean of metric for all simulated sequences
# can suppress print statements with verbose = FALSE (default TRUE)
for(seq_iter in 1:num_seq){
cat("\nIteration", seq_iter, "begin.\n")
A.tensor <- A.all_seq[seq_iter,,,,] # a particular sequence with dim 150  50  50   4
# splitting data in half
A.tensor.even <- A.tensor[seq(2, num_T, by = 2), , , ]
B.tensor.odd  <- A.tensor[seq(1, num_T-1, by = 2), , , ] # named as B.tensor
gains <- cusum_on_intervals(CUSUM_step1, A.tensor.even, verbose = FALSE, intervals, obj.B = B.tensor.odd)
results_g <- seeded_binary_seg(CUSUM_step1, A.tensor.even, num_T/2, CUSUM_res = gains, verbose = FALSE,
threshold = threshold_list, method = "Greedy", obj.B = B.tensor.odd)
for (i in 1:(length(results_g)-1)) {
detected_CP_g <- sort(results_g[[i+1]]$results[, 1])
detected_CP_gl1 <- refinement1(detected_CP_g, A.tensor.even, B.tensor.odd, hat.rank)
output_holder_g[seq_iter, i, ] <- as.numeric(eval_CP(true_CP, 2*detected_CP_g, num_T))
output_holder_gl1[seq_iter, i, ] <- as.numeric(eval_CP(true_CP, 2*detected_CP_gl1, num_T))
cat("Threshold: ", threshold_list[i], "\n")
cat("\tDetected Greedy CP  :", 2*detected_CP_g, ". Metrics: ", output_holder_g[seq_iter, i, ], "\n")
cat("\tRefinement Greedy   :", 2*detected_CP_gl1, ". Metrics: ", output_holder_gl1[seq_iter, i, ], "\n")
}
}
sce_100 <- list(
greedy = output_holder_g,
greedyl1 = output_holder_gl1
)
save(sce_100, file = "results/sce6_100.RData")
}
library(rTensor)
source("SBS.R")
source("CUSUM.R")
source("eval.R")
run_sensitivity <- function(both = TRUE) {
confirm <- function(label) {
repeat {
ans <- readline(paste0("Did you check ", label, "? (y/n): "))
if (tolower(ans) == "y") break
if (tolower(ans) == "n") stop(paste("Please fix ", label, " before proceeding."))
cat("Please answer 'y' or 'n'.\n")
}
}
confirm("true_cp")
confirm("load files for 50 and 100")
confirm("save files for 50 and 100")
cat("All settings confirmed. Proceeding...\n")
# true_CP <- c(40, 60) # Sce 1, 5
# true_CP <- c(50,100) # Sce 2, 6*, 8*
true_CP <- c(20, 60, 120, 150) #Sce 8b
# true_CP <- c(50,100,150,200,250) # Sce 3
# true_CP <- c(20, 60, 80, 160, 180) #Sce 3b
# true_CP <- c() # Sce 4
# true_CP <- c(20,50,80) # Sce 7
load("data/seq10n50s8b.RData") # Scenario 1 with node 50
# Generate data 0
num_seq <- dim(A.all_seq)[1] # 10 sequences
num_T <- dim(A.all_seq)[2] # 150 time points
num_node <- dim(A.all_seq)[3]
num_layer <- dim(A.all_seq)[5]
hat.rank <- c(15, 15, num_layer) # needed for model selection (Question: should be used as input to some FUNC)
# c(0.1, 0.2, 0.25, 0.3, 0.4)
# c(0.05, 0.1, 0.15, 0.2, 0.3, 0.4, 0.5, 0.7, 0.9)
threshold_list <- rev(c(0.05, 0.1, 0.15, 0.2, 0.25, 0.3) * num_node*sqrt(num_layer)*(log(num_T/2))^(3/2))
seq_iter <- 1 # used to test INSIDE the for-loop
intervals <- construct_intervals(num_T/2, sqrt(1/2), 4)
output_holder_g <- array(NA, dim = c(num_seq, length(threshold_list), 4))
output_holder_gl1 <- array(NA, dim = c(num_seq, length(threshold_list), 4))
# report mean of metric for all simulated sequences
# can suppress print statements with verbose = FALSE (default TRUE)
for(seq_iter in 1:num_seq) {
# Generate data 1 by 1
cat("\nIteration", seq_iter, "begin.\n")
A.tensor <- A.all_seq[seq_iter,,,,] # a particular sequence with dim 150  50  50   4
# splitting data in half
A.tensor.even <- A.tensor[seq(2, num_T, by = 2), , , ]
B.tensor.odd  <- A.tensor[seq(1, num_T-1, by = 2), , , ] # named as B.tensor
gains <- cusum_on_intervals(CUSUM_step1, A.tensor.even, verbose = FALSE, intervals, obj.B = B.tensor.odd)
results_g <- seeded_binary_seg(CUSUM_step1, A.tensor.even, num_T/2, CUSUM_res = gains, verbose = FALSE,
threshold = threshold_list, method = "Greedy", obj.B = B.tensor.odd)
for (i in 1:(length(results_g)-1)) {
detected_CP_g <- sort(results_g[[i+1]]$results[, 1])
detected_CP_gl1 <- refinement1(detected_CP_g, A.tensor.even, B.tensor.odd, hat.rank)
output_holder_g[seq_iter, i, ] <- as.numeric(eval_CP(true_CP, 2*detected_CP_g, num_T))
output_holder_gl1[seq_iter, i, ] <- as.numeric(eval_CP(true_CP, 2*detected_CP_gl1, num_T))
cat("Threshold: ", threshold_list[i], "\n")
cat("\tDetected Greedy CP  :", 2*detected_CP_g, ". Metrics: ", output_holder_g[seq_iter, i, ], "\n")
cat("\tRefinement Greedy   :", 2*detected_CP_gl1, ". Metrics: ", output_holder_gl1[seq_iter, i, ], "\n")
}
}
sce_50 <- list(
greedy = output_holder_g,
greedyl1 = output_holder_gl1
)
save(sce_50, file = "results/sce8b_50.RData")
if(both == FALSE) {return ()}
load("data/seq10n100s6.RData") # Scenario 1 with node 100
num_seq <- dim(A.all_seq)[1] # 10 sequences
num_T <- dim(A.all_seq)[2] # 150 time points
num_node <- dim(A.all_seq)[3]
num_layer <- dim(A.all_seq)[5]
hat.rank <- c(15, 15, num_layer) # needed for model selection (Question: should be used as input to some FUNC)
threshold_list <- rev(c(0.05, 0.1, 0.15, 0.2, 0.3, 0.4, 0.5, 0.7, 0.9) * num_node*sqrt(num_layer)*(log(num_T/2))^(3/2))
seq_iter <- 1 # used to test INSIDE the for-loop
intervals <- construct_intervals(num_T/2, sqrt(1/2), 4)
output_holder_g <- array(NA, dim = c(num_seq, length(threshold_list), 4))
output_holder_gl1 <- array(NA, dim = c(num_seq, length(threshold_list), 4))
# report mean of metric for all simulated sequences
# can suppress print statements with verbose = FALSE (default TRUE)
for(seq_iter in 1:num_seq){
cat("\nIteration", seq_iter, "begin.\n")
A.tensor <- A.all_seq[seq_iter,,,,] # a particular sequence with dim 150  50  50   4
# splitting data in half
A.tensor.even <- A.tensor[seq(2, num_T, by = 2), , , ]
B.tensor.odd  <- A.tensor[seq(1, num_T-1, by = 2), , , ] # named as B.tensor
gains <- cusum_on_intervals(CUSUM_step1, A.tensor.even, verbose = FALSE, intervals, obj.B = B.tensor.odd)
results_g <- seeded_binary_seg(CUSUM_step1, A.tensor.even, num_T/2, CUSUM_res = gains, verbose = FALSE,
threshold = threshold_list, method = "Greedy", obj.B = B.tensor.odd)
for (i in 1:(length(results_g)-1)) {
detected_CP_g <- sort(results_g[[i+1]]$results[, 1])
detected_CP_gl1 <- refinement1(detected_CP_g, A.tensor.even, B.tensor.odd, hat.rank)
output_holder_g[seq_iter, i, ] <- as.numeric(eval_CP(true_CP, 2*detected_CP_g, num_T))
output_holder_gl1[seq_iter, i, ] <- as.numeric(eval_CP(true_CP, 2*detected_CP_gl1, num_T))
cat("Threshold: ", threshold_list[i], "\n")
cat("\tDetected Greedy CP  :", 2*detected_CP_g, ". Metrics: ", output_holder_g[seq_iter, i, ], "\n")
cat("\tRefinement Greedy   :", 2*detected_CP_gl1, ". Metrics: ", output_holder_gl1[seq_iter, i, ], "\n")
}
}
sce_100 <- list(
greedy = output_holder_g,
greedyl1 = output_holder_gl1
)
save(sce_100, file = "results/sce6_100.RData")
}
run_sensitivity(FALSE)
