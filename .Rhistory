# report mean of metric for all simulated sequences
# can suppress print statements with verbose = FALSE (default TRUE)
for(seq_iter in 1:num_seq){
cat("\nIteration", seq_iter, "begin.\n")
A.tensor <- A.all_seq[seq_iter,,,,] # a particular sequence with dim 150  50  50   4
# splitting data in half
A.tensor.even <- A.tensor[seq(2, num_T, by = 2), , , ]
B.tensor.odd  <- A.tensor[seq(1, num_T-1, by = 2), , , ] # named as B.tensor
gains <- cusum_on_intervals(CUSUM_step1, A.tensor.even, verbose = FALSE, intervals, obj.B = B.tensor.odd)
results_g <- seeded_binary_seg(CUSUM_step1, A.tensor.even, num_T/2, CUSUM_res = gains, verbose = FALSE,
threshold = threshold_list, method = "Greedy", obj.B = B.tensor.odd)
for (i in 1:length(threshold_list)) {
detected_CP_g <- sort(results_g[[i+1]]$results[, 1])
detected_CP_gl1 <- refinement1(detected_CP_g, A.tensor.even, B.tensor.odd, hat.rank)
# detected_CP_gl2 <- refinement2(detected_CP_g, A.tensor.even, B.tensor.odd, hat.rank)
output_holder_g[seq_iter, i, ] <- as.numeric(eval_CP(true_CP, 2*detected_CP_g, num_T))
output_holder_gl1[seq_iter, i, ] <- as.numeric(eval_CP(true_CP, 2*detected_CP_gl1, num_T))
# output_holder_gl2[seq_iter, i, ] <- as.numeric(eval_CP(true_CP, 2*detected_CP_gl2, num_T))
cat("Threshold: ", threshold_list[i], "\n")
cat("\tDetected Greedy CP  :", 2*detected_CP_g, ". Metrics: ", output_holder_g[seq_iter, i, ], "\n")
cat("\tRefinement Greedy   :", 2*detected_CP_gl1, ". Metrics: ", output_holder_gl1[seq_iter, i, ], "\n")
# cat("\tRefinement 2 Greedy :", 2*detected_CP_gl2, ". Metrics: ", output_holder_gl2[seq_iter, i, ], "\n")
}
results_n <- seeded_binary_seg(CUSUM_step1, A.tensor.even, num_T/2, CUSUM_res = gains, verbose = FALSE,
threshold = threshold_list, method = "Narrowest", obj.B = B.tensor.odd)
for (i in 1:length(threshold_list)) {
detected_CP_n <- sort(results_n[[i+1]]$results[, 1])
detected_CP_nl1 <- refinement1(detected_CP_n, A.tensor.even, B.tensor.odd, hat.rank)
# detected_CP_nl2 <- refinement2(detected_CP_n, A.tensor.even, B.tensor.odd, hat.rank)
output_holder_n[seq_iter, i, ] <- as.numeric(eval_CP(true_CP, 2*detected_CP_n, num_T))
output_holder_nl1[seq_iter, i, ] <- as.numeric(eval_CP(true_CP, 2*detected_CP_nl1, num_T))
# output_holder_nl2[seq_iter, i, ] <- as.numeric(eval_CP(true_CP, 2*detected_CP_nl2, num_T))
cat("Threshold: ", threshold_list[i], "\n")
cat("\tDetected Narrowest CP  :", 2*detected_CP_n, ". Metrics: ", output_holder_n[seq_iter, i, ], "\n")
cat("\tRefinement Narrowest   :", 2*detected_CP_nl1, ". Metrics: ", output_holder_nl1[seq_iter, i, ], "\n")
# cat("\tRefinement 2 Narrowest :", 2*detected_CP_nl2, ". Metrics: ", output_holder_nl2[seq_iter, i, ], "\n")
}
}
output_holder_g[,3,]
output_holder_gl1[,3,]
output_holder_n[,3,]
output_holder_nl1[,3,]
library(rTensor)
source("SBS.R")
source("CUSUM.R")
source("eval.R")
get_blockwise_const_mat <- function(n, n_c, p_1, p_2){
# n: num node, n_c: num block, p1: between prob, p2: inter prob
# output n by n matrix with same block size
P = matrix(p_1, n, n)
size_c = floor(n / n_c)
for (k in 1:n_c){
if (k < n_c){
P[(1 + size_c*(k-1)):(size_c * k), (1 + size_c*(k-1)):(size_c * k)] = p_2
} else {
P[(1 + size_c*(n_c-1)):n, (1 + size_c*(n_c-1)):n] = p_2
}
}
return(P)
}
get_sbm_params <- function(n, L, n_c=c(4, 4, 4)){
# output probability matrix before and after, each with (n,n L)
# block size fixed
probability_1 = array(NA, c(n, n, L))
probability_2 = array(NA, c(n, n, L))
probability_3 = array(NA, c(n, n, L))
# Define increasing probability ranges for each window
prob_ranges <- list(
c(0.31, 0.4),   # sparse
c(0.41, 0.5),  # moderate
c(0.51, 0.6)     # dense
)
for (layer in 1: L) {
p1_vals <- sapply(prob_ranges, function(rng) runif(1, rng[1]/2, rng[2]/2)) # inter is lower
p2_vals <- sapply(prob_ranges, function(rng) runif(1, rng[1], rng[2]))
# Generate the blockwise adjacency matrices for each set of probabilities
P = get_blockwise_const_mat(n, n_c[1], p1_vals[1], p2_vals[1])
probability_1[, , layer] = P
P = get_blockwise_const_mat(n, n_c[2], p1_vals[2], p2_vals[2])
probability_2[, , layer] = P
P = get_blockwise_const_mat(n, n_c[3], p1_vals[3], p2_vals[3])
probability_3[, , layer] = P
}
return(list(probability_1, probability_2, probability_3))
}
num_seq = 5
num_time = 150
num_node = 50
num_layer = 4
sbm_params <- get_sbm_params(n=50, L=4, n_c=c(4, 4, 4))
probability_1 = sbm_params[[1]]
probability_2 = sbm_params[[2]]
probability_3 = sbm_params[[3]]
A.all_seq <- array(NA, c(num_seq, num_time, num_node, num_node, num_layer)) # i.e. 10 sequences empty
# begin simulate data
for(seq_iter in 1:num_seq){
A.tensor <- array(NA, c(num_time, num_node, num_node, num_layer)) # 1 sequence
# T from 1 to 150 (otherwise change the for loop)
for(t_iter in 1:50) A.tensor[t_iter,,,]    <- generate_tensor_probability_directed(n_1=num_node, n_2=num_node, L=num_layer, probability_1)
for(t_iter in 51:100) A.tensor[t_iter,,,]  <- generate_tensor_probability_directed(n_1=num_node, n_2=num_node, L=num_layer, probability_2)
for(t_iter in 101:150) A.tensor[t_iter,,,] <- generate_tensor_probability_directed(n_1=num_node, n_2=num_node, L=num_layer, probability_3)
A.all_seq[seq_iter,,,,] <- A.tensor
}; rm(seq_iter, A.tensor)
true_CP <- c(50,100)
num_seq <- dim(A.all_seq)[1] # 10 sequences
num_T <- dim(A.all_seq)[2] # 150 time points
num_node <- dim(A.all_seq)[3]
num_layer <- dim(A.all_seq)[5]
hat.rank <- c(15, 15, num_layer) # needed for model selection (Question: should be used as input to some FUNC)
threshold_list <- rev(c(0.2, 0.4, 0.5, 0.6, 0.8) * num_node*sqrt(num_layer)*(log(num_T/2))^(3/2))
intervals <- construct_intervals(num_T/2, sqrt(1/2), 4)
output_holder_g <- array(NA, dim = c(num_seq, length(threshold_list), 4))
output_holder_gl1 <- array(NA, dim = c(num_seq, length(threshold_list), 4))
output_holder_gl2 <- array(NA, dim = c(num_seq, length(threshold_list), 4))
output_holder_n <- array(NA, dim = c(num_seq, length(threshold_list), 4))
output_holder_nl1 <- array(NA, dim = c(num_seq, length(threshold_list), 4))
output_holder_nl2 <- array(NA, dim = c(num_seq, length(threshold_list), 4))
# report mean of metric for all simulated sequences
# can suppress print statements with verbose = FALSE (default TRUE)
for(seq_iter in 1:num_seq){
cat("\nIteration", seq_iter, "begin.\n")
A.tensor <- A.all_seq[seq_iter,,,,] # a particular sequence with dim 150  50  50   4
# splitting data in half
A.tensor.even <- A.tensor[seq(2, num_T, by = 2), , , ]
B.tensor.odd  <- A.tensor[seq(1, num_T-1, by = 2), , , ] # named as B.tensor
gains <- cusum_on_intervals(CUSUM_step1, A.tensor.even, verbose = FALSE, intervals, obj.B = B.tensor.odd)
results_g <- seeded_binary_seg(CUSUM_step1, A.tensor.even, num_T/2, CUSUM_res = gains, verbose = FALSE,
threshold = threshold_list, method = "Greedy", obj.B = B.tensor.odd)
for (i in 1:length(threshold_list)) {
detected_CP_g <- sort(results_g[[i+1]]$results[, 1])
detected_CP_gl1 <- refinement1(detected_CP_g, A.tensor.even, B.tensor.odd, hat.rank)
# detected_CP_gl2 <- refinement2(detected_CP_g, A.tensor.even, B.tensor.odd, hat.rank)
output_holder_g[seq_iter, i, ] <- as.numeric(eval_CP(true_CP, 2*detected_CP_g, num_T))
output_holder_gl1[seq_iter, i, ] <- as.numeric(eval_CP(true_CP, 2*detected_CP_gl1, num_T))
# output_holder_gl2[seq_iter, i, ] <- as.numeric(eval_CP(true_CP, 2*detected_CP_gl2, num_T))
cat("Threshold: ", threshold_list[i], "\n")
cat("\tDetected Greedy CP  :", 2*detected_CP_g, ". Metrics: ", output_holder_g[seq_iter, i, ], "\n")
cat("\tRefinement Greedy   :", 2*detected_CP_gl1, ". Metrics: ", output_holder_gl1[seq_iter, i, ], "\n")
# cat("\tRefinement 2 Greedy :", 2*detected_CP_gl2, ". Metrics: ", output_holder_gl2[seq_iter, i, ], "\n")
}
results_n <- seeded_binary_seg(CUSUM_step1, A.tensor.even, num_T/2, CUSUM_res = gains, verbose = FALSE,
threshold = threshold_list, method = "Narrowest", obj.B = B.tensor.odd)
for (i in 1:length(threshold_list)) {
detected_CP_n <- sort(results_n[[i+1]]$results[, 1])
detected_CP_nl1 <- refinement1(detected_CP_n, A.tensor.even, B.tensor.odd, hat.rank)
# detected_CP_nl2 <- refinement2(detected_CP_n, A.tensor.even, B.tensor.odd, hat.rank)
output_holder_n[seq_iter, i, ] <- as.numeric(eval_CP(true_CP, 2*detected_CP_n, num_T))
output_holder_nl1[seq_iter, i, ] <- as.numeric(eval_CP(true_CP, 2*detected_CP_nl1, num_T))
# output_holder_nl2[seq_iter, i, ] <- as.numeric(eval_CP(true_CP, 2*detected_CP_nl2, num_T))
cat("Threshold: ", threshold_list[i], "\n")
cat("\tDetected Narrowest CP  :", 2*detected_CP_n, ". Metrics: ", output_holder_n[seq_iter, i, ], "\n")
cat("\tRefinement Narrowest   :", 2*detected_CP_nl1, ". Metrics: ", output_holder_nl1[seq_iter, i, ], "\n")
# cat("\tRefinement 2 Narrowest :", 2*detected_CP_nl2, ". Metrics: ", output_holder_nl2[seq_iter, i, ], "\n")
}
}
output_holder_g[,3,]
output_holder_gl1[,3,]
output_holder_n[,3,]
output_holder_nl1[,3,]
library(rTensor)
source("SBS.R")
source("CUSUM.R")
source("eval.R")
get_blockwise_const_mat <- function(n, n_c, p_1, p_2){
# n: num node, n_c: num block, p1: between prob, p2: inter prob
# output n by n matrix with same block size
P = matrix(p_1, n, n)
size_c = floor(n / n_c)
for (k in 1:n_c){
if (k < n_c){
P[(1 + size_c*(k-1)):(size_c * k), (1 + size_c*(k-1)):(size_c * k)] = p_2
} else {
P[(1 + size_c*(n_c-1)):n, (1 + size_c*(n_c-1)):n] = p_2
}
}
return(P)
}
get_sbm_params <- function(n, L, n_c=c(4, 4, 4)){
# output probability matrix before and after, each with (n,n L)
# block size fixed
probability_1 = array(NA, c(n, n, L))
probability_2 = array(NA, c(n, n, L))
probability_3 = array(NA, c(n, n, L))
# Define increasing probability ranges for each window
prob_ranges <- list(
c(0.21, 0.3),   # sparse
c(0.31, 0.4),  # moderate
c(0.41, 0.5)     # dense
)
for (layer in 1: L) {
p1_vals <- sapply(prob_ranges, function(rng) runif(1, rng[1]/2, rng[2]/2)) # inter is lower
p2_vals <- sapply(prob_ranges, function(rng) runif(1, rng[1], rng[2]))
# Generate the blockwise adjacency matrices for each set of probabilities
P = get_blockwise_const_mat(n, n_c[1], p1_vals[1], p2_vals[1])
probability_1[, , layer] = P
P = get_blockwise_const_mat(n, n_c[2], p1_vals[2], p2_vals[2])
probability_2[, , layer] = P
P = get_blockwise_const_mat(n, n_c[3], p1_vals[3], p2_vals[3])
probability_3[, , layer] = P
}
return(list(probability_1, probability_2, probability_3))
}
num_seq = 3
num_time = 150
num_node = 50
num_layer = 4
sbm_params <- get_sbm_params(n=50, L=4, n_c=c(4, 4, 4))
probability_1 = sbm_params[[1]]
probability_2 = sbm_params[[2]]
probability_3 = sbm_params[[3]]
A.all_seq <- array(NA, c(num_seq, num_time, num_node, num_node, num_layer)) # i.e. 10 sequences empty
# begin simulate data
for(seq_iter in 1:num_seq){
A.tensor <- array(NA, c(num_time, num_node, num_node, num_layer)) # 1 sequence
# T from 1 to 150 (otherwise change the for loop)
for(t_iter in 1:60) A.tensor[t_iter,,,]    <- generate_tensor_probability_directed(n_1=num_node, n_2=num_node, L=num_layer, probability_1)
for(t_iter in 61:70) A.tensor[t_iter,,,]  <- generate_tensor_probability_directed(n_1=num_node, n_2=num_node, L=num_layer, probability_2)
for(t_iter in 71:150) A.tensor[t_iter,,,] <- generate_tensor_probability_directed(n_1=num_node, n_2=num_node, L=num_layer, probability_3)
A.all_seq[seq_iter,,,,] <- A.tensor
}; rm(seq_iter, A.tensor)
true_CP <- c(60,70)
num_seq <- dim(A.all_seq)[1] # 10 sequences
num_T <- dim(A.all_seq)[2] # 150 time points
num_node <- dim(A.all_seq)[3]
num_layer <- dim(A.all_seq)[5]
hat.rank <- c(15, 15, num_layer) # needed for model selection (Question: should be used as input to some FUNC)
threshold_list <- rev(c(0.2, 0.4, 0.5, 0.6, 0.8) * num_node*sqrt(num_layer)*(log(num_T/2))^(3/2))
intervals <- construct_intervals(num_T/2, sqrt(1/2), 4)
output_holder_g <- array(NA, dim = c(num_seq, length(threshold_list), 4))
output_holder_gl1 <- array(NA, dim = c(num_seq, length(threshold_list), 4))
output_holder_gl2 <- array(NA, dim = c(num_seq, length(threshold_list), 4))
output_holder_n <- array(NA, dim = c(num_seq, length(threshold_list), 4))
output_holder_nl1 <- array(NA, dim = c(num_seq, length(threshold_list), 4))
output_holder_nl2 <- array(NA, dim = c(num_seq, length(threshold_list), 4))
# report mean of metric for all simulated sequences
# can suppress print statements with verbose = FALSE (default TRUE)
for(seq_iter in 1:num_seq){
cat("\nIteration", seq_iter, "begin.\n")
A.tensor <- A.all_seq[seq_iter,,,,] # a particular sequence with dim 150  50  50   4
# splitting data in half
A.tensor.even <- A.tensor[seq(2, num_T, by = 2), , , ]
B.tensor.odd  <- A.tensor[seq(1, num_T-1, by = 2), , , ] # named as B.tensor
gains <- cusum_on_intervals(CUSUM_step1, A.tensor.even, verbose = FALSE, intervals, obj.B = B.tensor.odd)
results_g <- seeded_binary_seg(CUSUM_step1, A.tensor.even, num_T/2, CUSUM_res = gains, verbose = FALSE,
threshold = threshold_list, method = "Greedy", obj.B = B.tensor.odd)
for (i in 1:length(threshold_list)) {
detected_CP_g <- sort(results_g[[i+1]]$results[, 1])
detected_CP_gl1 <- refinement1(detected_CP_g, A.tensor.even, B.tensor.odd, hat.rank)
# detected_CP_gl2 <- refinement2(detected_CP_g, A.tensor.even, B.tensor.odd, hat.rank)
output_holder_g[seq_iter, i, ] <- as.numeric(eval_CP(true_CP, 2*detected_CP_g, num_T))
output_holder_gl1[seq_iter, i, ] <- as.numeric(eval_CP(true_CP, 2*detected_CP_gl1, num_T))
# output_holder_gl2[seq_iter, i, ] <- as.numeric(eval_CP(true_CP, 2*detected_CP_gl2, num_T))
cat("Threshold: ", threshold_list[i], "\n")
cat("\tDetected Greedy CP  :", 2*detected_CP_g, ". Metrics: ", output_holder_g[seq_iter, i, ], "\n")
cat("\tRefinement Greedy   :", 2*detected_CP_gl1, ". Metrics: ", output_holder_gl1[seq_iter, i, ], "\n")
# cat("\tRefinement 2 Greedy :", 2*detected_CP_gl2, ". Metrics: ", output_holder_gl2[seq_iter, i, ], "\n")
}
results_n <- seeded_binary_seg(CUSUM_step1, A.tensor.even, num_T/2, CUSUM_res = gains, verbose = FALSE,
threshold = threshold_list, method = "Narrowest", obj.B = B.tensor.odd)
for (i in 1:length(threshold_list)) {
detected_CP_n <- sort(results_n[[i+1]]$results[, 1])
detected_CP_nl1 <- refinement1(detected_CP_n, A.tensor.even, B.tensor.odd, hat.rank)
# detected_CP_nl2 <- refinement2(detected_CP_n, A.tensor.even, B.tensor.odd, hat.rank)
output_holder_n[seq_iter, i, ] <- as.numeric(eval_CP(true_CP, 2*detected_CP_n, num_T))
output_holder_nl1[seq_iter, i, ] <- as.numeric(eval_CP(true_CP, 2*detected_CP_nl1, num_T))
# output_holder_nl2[seq_iter, i, ] <- as.numeric(eval_CP(true_CP, 2*detected_CP_nl2, num_T))
cat("Threshold: ", threshold_list[i], "\n")
cat("\tDetected Narrowest CP  :", 2*detected_CP_n, ". Metrics: ", output_holder_n[seq_iter, i, ], "\n")
cat("\tRefinement Narrowest   :", 2*detected_CP_nl1, ". Metrics: ", output_holder_nl1[seq_iter, i, ], "\n")
# cat("\tRefinement 2 Narrowest :", 2*detected_CP_nl2, ". Metrics: ", output_holder_nl2[seq_iter, i, ], "\n")
}
}
output_holder_g[,3,]
output_holder_gl1[,3,]
output_holder_n[,3,]
output_holder_nl1[,3,]
library(rTensor)
source("SBS.R")
source("CUSUM.R")
source("eval.R")
get_blockwise_const_mat <- function(n, n_c, p_1, p_2){
# n: num node, n_c: num block, p1: between prob, p2: inter prob
# output n by n matrix with same block size
P = matrix(p_1, n, n)
size_c = floor(n / n_c)
for (k in 1:n_c){
if (k < n_c){
P[(1 + size_c*(k-1)):(size_c * k), (1 + size_c*(k-1)):(size_c * k)] = p_2
} else {
P[(1 + size_c*(n_c-1)):n, (1 + size_c*(n_c-1)):n] = p_2
}
}
return(P)
}
get_sbm_params <- function(n, L, n_c=c(4, 4, 4)){
# output probability matrix before and after, each with (n,n L)
# block size fixed
probability_1 = array(NA, c(n, n, L))
probability_2 = array(NA, c(n, n, L))
probability_3 = array(NA, c(n, n, L))
# Define increasing probability ranges for each window
prob_ranges <- list(
c(0.21, 0.25),   # sparse
c(0.26, 0.3),  # moderate
c(0.31, 0.35)     # dense
)
for (layer in 1: L) {
p1_vals <- sapply(prob_ranges, function(rng) runif(1, rng[1]/2, rng[2]/2)) # inter is lower
p2_vals <- sapply(prob_ranges, function(rng) runif(1, rng[1], rng[2]))
# Generate the blockwise adjacency matrices for each set of probabilities
P = get_blockwise_const_mat(n, n_c[1], p1_vals[1], p2_vals[1])
probability_1[, , layer] = P
P = get_blockwise_const_mat(n, n_c[2], p1_vals[2], p2_vals[2])
probability_2[, , layer] = P
P = get_blockwise_const_mat(n, n_c[3], p1_vals[3], p2_vals[3])
probability_3[, , layer] = P
}
return(list(probability_1, probability_2, probability_3))
}
num_seq = 3
num_time = 150
num_node = 50
num_layer = 4
sbm_params <- get_sbm_params(n=50, L=4, n_c=c(4, 4, 4))
probability_1 = sbm_params[[1]]
probability_2 = sbm_params[[2]]
probability_3 = sbm_params[[3]]
A.all_seq <- array(NA, c(num_seq, num_time, num_node, num_node, num_layer)) # i.e. 10 sequences empty
# begin simulate data
for(seq_iter in 1:num_seq){
A.tensor <- array(NA, c(num_time, num_node, num_node, num_layer)) # 1 sequence
# T from 1 to 150 (otherwise change the for loop)
for(t_iter in 1:60) A.tensor[t_iter,,,]    <- generate_tensor_probability_directed(n_1=num_node, n_2=num_node, L=num_layer, probability_1)
for(t_iter in 61:70) A.tensor[t_iter,,,]  <- generate_tensor_probability_directed(n_1=num_node, n_2=num_node, L=num_layer, probability_2)
for(t_iter in 71:150) A.tensor[t_iter,,,] <- generate_tensor_probability_directed(n_1=num_node, n_2=num_node, L=num_layer, probability_3)
A.all_seq[seq_iter,,,,] <- A.tensor
}; rm(seq_iter, A.tensor)
true_CP <- c(60,70)
num_seq <- dim(A.all_seq)[1] # 10 sequences
num_T <- dim(A.all_seq)[2] # 150 time points
num_node <- dim(A.all_seq)[3]
num_layer <- dim(A.all_seq)[5]
hat.rank <- c(15, 15, num_layer) # needed for model selection (Question: should be used as input to some FUNC)
threshold_list <- rev(c(0.2, 0.4, 0.5, 0.6, 0.8) * num_node*sqrt(num_layer)*(log(num_T/2))^(3/2))
intervals <- construct_intervals(num_T/2, sqrt(1/2), 4)
output_holder_g <- array(NA, dim = c(num_seq, length(threshold_list), 4))
output_holder_gl1 <- array(NA, dim = c(num_seq, length(threshold_list), 4))
output_holder_gl2 <- array(NA, dim = c(num_seq, length(threshold_list), 4))
output_holder_n <- array(NA, dim = c(num_seq, length(threshold_list), 4))
output_holder_nl1 <- array(NA, dim = c(num_seq, length(threshold_list), 4))
output_holder_nl2 <- array(NA, dim = c(num_seq, length(threshold_list), 4))
# report mean of metric for all simulated sequences
# can suppress print statements with verbose = FALSE (default TRUE)
for(seq_iter in 1:num_seq){
cat("\nIteration", seq_iter, "begin.\n")
A.tensor <- A.all_seq[seq_iter,,,,] # a particular sequence with dim 150  50  50   4
# splitting data in half
A.tensor.even <- A.tensor[seq(2, num_T, by = 2), , , ]
B.tensor.odd  <- A.tensor[seq(1, num_T-1, by = 2), , , ] # named as B.tensor
gains <- cusum_on_intervals(CUSUM_step1, A.tensor.even, verbose = FALSE, intervals, obj.B = B.tensor.odd)
results_g <- seeded_binary_seg(CUSUM_step1, A.tensor.even, num_T/2, CUSUM_res = gains, verbose = FALSE,
threshold = threshold_list, method = "Greedy", obj.B = B.tensor.odd)
for (i in 1:length(threshold_list)) {
detected_CP_g <- sort(results_g[[i+1]]$results[, 1])
detected_CP_gl1 <- refinement1(detected_CP_g, A.tensor.even, B.tensor.odd, hat.rank)
# detected_CP_gl2 <- refinement2(detected_CP_g, A.tensor.even, B.tensor.odd, hat.rank)
output_holder_g[seq_iter, i, ] <- as.numeric(eval_CP(true_CP, 2*detected_CP_g, num_T))
output_holder_gl1[seq_iter, i, ] <- as.numeric(eval_CP(true_CP, 2*detected_CP_gl1, num_T))
# output_holder_gl2[seq_iter, i, ] <- as.numeric(eval_CP(true_CP, 2*detected_CP_gl2, num_T))
cat("Threshold: ", threshold_list[i], "\n")
cat("\tDetected Greedy CP  :", 2*detected_CP_g, ". Metrics: ", output_holder_g[seq_iter, i, ], "\n")
cat("\tRefinement Greedy   :", 2*detected_CP_gl1, ". Metrics: ", output_holder_gl1[seq_iter, i, ], "\n")
# cat("\tRefinement 2 Greedy :", 2*detected_CP_gl2, ". Metrics: ", output_holder_gl2[seq_iter, i, ], "\n")
}
results_n <- seeded_binary_seg(CUSUM_step1, A.tensor.even, num_T/2, CUSUM_res = gains, verbose = FALSE,
threshold = threshold_list, method = "Narrowest", obj.B = B.tensor.odd)
for (i in 1:length(threshold_list)) {
detected_CP_n <- sort(results_n[[i+1]]$results[, 1])
detected_CP_nl1 <- refinement1(detected_CP_n, A.tensor.even, B.tensor.odd, hat.rank)
# detected_CP_nl2 <- refinement2(detected_CP_n, A.tensor.even, B.tensor.odd, hat.rank)
output_holder_n[seq_iter, i, ] <- as.numeric(eval_CP(true_CP, 2*detected_CP_n, num_T))
output_holder_nl1[seq_iter, i, ] <- as.numeric(eval_CP(true_CP, 2*detected_CP_nl1, num_T))
# output_holder_nl2[seq_iter, i, ] <- as.numeric(eval_CP(true_CP, 2*detected_CP_nl2, num_T))
cat("Threshold: ", threshold_list[i], "\n")
cat("\tDetected Narrowest CP  :", 2*detected_CP_n, ". Metrics: ", output_holder_n[seq_iter, i, ], "\n")
cat("\tRefinement Narrowest   :", 2*detected_CP_nl1, ". Metrics: ", output_holder_nl1[seq_iter, i, ], "\n")
# cat("\tRefinement 2 Narrowest :", 2*detected_CP_nl2, ". Metrics: ", output_holder_nl2[seq_iter, i, ], "\n")
}
}
output_holder_g[,3,]
output_holder_gl1[,3,]
output_holder_n[,3,]
output_holder_nl1[,3,]
library(rTensor)
source("SBS.R")
source("CUSUM.R")
source("eval.R")
get_blockwise_const_mat <- function(n, n_c, p_1, p_2){
# n: num node, n_c: num block, p1: between prob, p2: inter prob
# output n by n matrix with same block size
P = matrix(p_1, n, n)
size_c = floor(n / n_c)
for (k in 1:n_c){
if (k < n_c){
P[(1 + size_c*(k-1)):(size_c * k), (1 + size_c*(k-1)):(size_c * k)] = p_2
} else {
P[(1 + size_c*(n_c-1)):n, (1 + size_c*(n_c-1)):n] = p_2
}
}
return(P)
}
get_sbm_params <- function(n, L, n_c=c(4, 4, 4)){
# output probability matrix before and after, each with (n,n L)
# block size fixed
probability_1 = array(NA, c(n, n, L))
probability_2 = array(NA, c(n, n, L))
probability_3 = array(NA, c(n, n, L))
# Define increasing probability ranges for each window
prob_ranges <- list(
c(0.21, 0.25),   # sparse
c(0.26, 0.3),  # moderate
c(0.31, 0.35)     # dense
)
for (layer in 1: L) {
p1_vals <- sapply(prob_ranges, function(rng) runif(1, rng[1]/2, rng[2]/2)) # inter is lower
p2_vals <- sapply(prob_ranges, function(rng) runif(1, rng[1], rng[2]))
# Generate the blockwise adjacency matrices for each set of probabilities
P = get_blockwise_const_mat(n, n_c[1], p1_vals[1], p2_vals[1])
probability_1[, , layer] = P
P = get_blockwise_const_mat(n, n_c[2], p1_vals[2], p2_vals[2])
probability_2[, , layer] = P
P = get_blockwise_const_mat(n, n_c[3], p1_vals[3], p2_vals[3])
probability_3[, , layer] = P
}
return(list(probability_1, probability_2, probability_3))
}
num_seq = 3
num_time = 150
num_node = 50
num_layer = 4
sbm_params <- get_sbm_params(n=50, L=4, n_c=c(4, 4, 4))
probability_1 = sbm_params[[1]]
probability_2 = sbm_params[[2]]
probability_3 = sbm_params[[3]]
A.all_seq <- array(NA, c(num_seq, num_time, num_node, num_node, num_layer)) # i.e. 10 sequences empty
# begin simulate data
for(seq_iter in 1:num_seq){
A.tensor <- array(NA, c(num_time, num_node, num_node, num_layer)) # 1 sequence
# T from 1 to 150 (otherwise change the for loop)
for(t_iter in 1:50) A.tensor[t_iter,,,]    <- generate_tensor_probability_directed(n_1=num_node, n_2=num_node, L=num_layer, probability_1)
for(t_iter in 51:70) A.tensor[t_iter,,,]  <- generate_tensor_probability_directed(n_1=num_node, n_2=num_node, L=num_layer, probability_2)
for(t_iter in 71:150) A.tensor[t_iter,,,] <- generate_tensor_probability_directed(n_1=num_node, n_2=num_node, L=num_layer, probability_3)
A.all_seq[seq_iter,,,,] <- A.tensor
}; rm(seq_iter, A.tensor)
true_CP <- c(50,70)
num_seq <- dim(A.all_seq)[1] # 10 sequences
num_T <- dim(A.all_seq)[2] # 150 time points
num_node <- dim(A.all_seq)[3]
num_layer <- dim(A.all_seq)[5]
hat.rank <- c(15, 15, num_layer) # needed for model selection (Question: should be used as input to some FUNC)
threshold_list <- rev(c(0.2, 0.4, 0.5, 0.6, 0.8) * num_node*sqrt(num_layer)*(log(num_T/2))^(3/2))
intervals <- construct_intervals(num_T/2, sqrt(1/2), 4)
output_holder_g <- array(NA, dim = c(num_seq, length(threshold_list), 4))
output_holder_gl1 <- array(NA, dim = c(num_seq, length(threshold_list), 4))
output_holder_gl2 <- array(NA, dim = c(num_seq, length(threshold_list), 4))
output_holder_n <- array(NA, dim = c(num_seq, length(threshold_list), 4))
output_holder_nl1 <- array(NA, dim = c(num_seq, length(threshold_list), 4))
output_holder_nl2 <- array(NA, dim = c(num_seq, length(threshold_list), 4))
# report mean of metric for all simulated sequences
# can suppress print statements with verbose = FALSE (default TRUE)
for(seq_iter in 1:num_seq){
cat("\nIteration", seq_iter, "begin.\n")
A.tensor <- A.all_seq[seq_iter,,,,] # a particular sequence with dim 150  50  50   4
# splitting data in half
A.tensor.even <- A.tensor[seq(2, num_T, by = 2), , , ]
B.tensor.odd  <- A.tensor[seq(1, num_T-1, by = 2), , , ] # named as B.tensor
gains <- cusum_on_intervals(CUSUM_step1, A.tensor.even, verbose = FALSE, intervals, obj.B = B.tensor.odd)
results_g <- seeded_binary_seg(CUSUM_step1, A.tensor.even, num_T/2, CUSUM_res = gains, verbose = FALSE,
threshold = threshold_list, method = "Greedy", obj.B = B.tensor.odd)
for (i in 1:length(threshold_list)) {
detected_CP_g <- sort(results_g[[i+1]]$results[, 1])
detected_CP_gl1 <- refinement1(detected_CP_g, A.tensor.even, B.tensor.odd, hat.rank)
# detected_CP_gl2 <- refinement2(detected_CP_g, A.tensor.even, B.tensor.odd, hat.rank)
output_holder_g[seq_iter, i, ] <- as.numeric(eval_CP(true_CP, 2*detected_CP_g, num_T))
output_holder_gl1[seq_iter, i, ] <- as.numeric(eval_CP(true_CP, 2*detected_CP_gl1, num_T))
# output_holder_gl2[seq_iter, i, ] <- as.numeric(eval_CP(true_CP, 2*detected_CP_gl2, num_T))
cat("Threshold: ", threshold_list[i], "\n")
cat("\tDetected Greedy CP  :", 2*detected_CP_g, ". Metrics: ", output_holder_g[seq_iter, i, ], "\n")
cat("\tRefinement Greedy   :", 2*detected_CP_gl1, ". Metrics: ", output_holder_gl1[seq_iter, i, ], "\n")
# cat("\tRefinement 2 Greedy :", 2*detected_CP_gl2, ". Metrics: ", output_holder_gl2[seq_iter, i, ], "\n")
}
results_n <- seeded_binary_seg(CUSUM_step1, A.tensor.even, num_T/2, CUSUM_res = gains, verbose = FALSE,
threshold = threshold_list, method = "Narrowest", obj.B = B.tensor.odd)
for (i in 1:length(threshold_list)) {
detected_CP_n <- sort(results_n[[i+1]]$results[, 1])
detected_CP_nl1 <- refinement1(detected_CP_n, A.tensor.even, B.tensor.odd, hat.rank)
# detected_CP_nl2 <- refinement2(detected_CP_n, A.tensor.even, B.tensor.odd, hat.rank)
output_holder_n[seq_iter, i, ] <- as.numeric(eval_CP(true_CP, 2*detected_CP_n, num_T))
output_holder_nl1[seq_iter, i, ] <- as.numeric(eval_CP(true_CP, 2*detected_CP_nl1, num_T))
# output_holder_nl2[seq_iter, i, ] <- as.numeric(eval_CP(true_CP, 2*detected_CP_nl2, num_T))
cat("Threshold: ", threshold_list[i], "\n")
cat("\tDetected Narrowest CP  :", 2*detected_CP_n, ". Metrics: ", output_holder_n[seq_iter, i, ], "\n")
cat("\tRefinement Narrowest   :", 2*detected_CP_nl1, ". Metrics: ", output_holder_nl1[seq_iter, i, ], "\n")
# cat("\tRefinement 2 Narrowest :", 2*detected_CP_nl2, ". Metrics: ", output_holder_nl2[seq_iter, i, ], "\n")
}
}
output_holder_g[,3,]
output_holder_gl1[,3,]
output_holder_n[,3,]
output_holder_nl1[,3,]
2024 - 1895
130*12
