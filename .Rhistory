# rm(list = ls())
#library(devtools)
install_github("statsmaths/glmgen", subdir="R_pkg/glmgen")
# rm(list = ls())
library(devtools)
# rm(list = ls())
install.packages("devtools")
library(devtools)
install_github("statsmaths/glmgen", subdir="R_pkg/glmgen")
library(glmgen)
library(plotly)
library(tidyverse)
library(extraDistr)
scenario0(500, 5, 0.5, TRUE)
scenario0 <- function(n, d, tau, plots = FALSE) {
# Scenario 0
# g_0 is piecewise constant function alternating between 1 and -1,
# at j + 2 breakpoints
# x drawn randomly from uniform distribution for each component
# f_0 <- a_j * piecewise_function - b_j with b_j such that mean(f_0) = 0
# and a_j such that norm(f_0) = 1
if (length(n) != 1 || length(d) != 1 || length(tau) != 1) {
stop("Scenario function is only suitable for a single scenario.\n
Please ensure inputs are each scalar values.")
}
x_list <- matrix(NA, nrow = d, ncol = n)
y_list <- matrix(NA, nrow = d, ncol = n)
piecewise_constant <- function(x, breakpoints, values) {
intervals <- findInterval(x, breakpoints)
return(values[intervals])
}
for (j in 1:d) {
x_list[j, ] <- runif(n, 0, 1)
# Define breakpoints for piecewise constant function
breakpoints <- seq(0, 1, length.out = j + 2)^2
values <- rep(c(1, -1), length.out = j + 1)  # alternating between 1 and -1
# Piecewise constant function
g_0 <- piecewise_constant(x_list[j, ], breakpoints, values)
b_j <- mean(g_0)
a_j <- 1 / (norm(g_0 - b_j, type = "2") / sqrt(n))
y_list[j, ] <- a_j * g_0 - a_j * b_j
if (plots) {
filename <- paste(getwd(), '/sce0_plot_', j, '.png', sep = '')
png(filename)
plot(y_list[j, ]~x_list[j, ], main = paste('Scenario 0 j =', j), xlab = 'x', ylab = 'y')
dev.off()
}
}
# Sum of each column of y_list
y_star <- colSums(y_list)
# T(3) errors
y <- y_star + rt(n, 3)
y_star_q <- y_star + qt(tau, 3)
if (tau != 0.5) { warning("Tau != 0.5. Only use output for QATF!")}
return(list(x_list, y, y_star_q))
}
scenario0(500, 5, 0.5, TRUE)
scenario0(500, 2, 0.5, TRUE)
breakpoints <- seq(0, 1, length.out = 8)^2
# Define the function using modular math
f <- function(x) {
# Find which interval x belongs to by checking which breakpoint it exceeds
interval <- findInterval(x, breakpoints)
# Alternate between 0 and 1 using modular math
return((interval %% 2) == 1) * 1  # Mod 2 to alternate, multiply by 1 to get 0/1 output
}
# Example usage:
x <- seq(0, 1, by = 0.05)
f(x)
# Example usage:
x <- seq(0, 1, length.out = 100)
plot(f(x)~x)
findInterval(x, breakpoints)
# Define the breakpoints
breakpoints <- seq(0, 1, length.out = 8)^2
# Define the function using modular math
f <- function(x) {
# Find which interval x belongs to, and ensure it stays within the range
interval <- pmin(findInterval(x, breakpoints), length(breakpoints) - 1)
# Alternate between 0 and 1 using modular math
return((interval %% 2) == 1) * 1  # Mod 2 to alternate, multiply by 1 to get 0/1 output
}
# Example usage:
x <- seq(0, 1, length.out = 100)
plot(f(x) ~ x)
# Example usage:
x <- seq(0, 1, length.out = 100)
plot(f(x) ~ x)
beta <- lapply(x, f)
f_bar <- mean(unlist(beta))
beta <- lapply(beta, function(b, adj) b - adj, f_bar)
plot(beta)
beta
plot(unlist(beta))
# Define the function using modular math
f <- function(x) {
breakpoints <- seq(0, 1, length.out = 8)^2
interval <- pmin(findInterval(x, breakpoints), length(breakpoints) - 1)
return((interval %% 2) == 1) * 2  -1
}
# Define the function using modular math
f <- function(x) {
breakpoints <- seq(0, 1, length.out = 8)^2
interval <- pmin(findInterval(x, breakpoints), length(breakpoints) - 1)
return((interval %% 2) == 1) * 2 - 1
}
# Example usage:
x <- seq(0, 1, length.out = 100)
plot(f(x) ~ x)
beta <- lapply(x, f)
f_bar <- mean(unlist(beta))
beta <- lapply(beta, function(b, adj) b - adj, f_bar)
plot(unlist(beta))
# Define the function using modular math
f <- function(x) {
breakpoints <- seq(0, 1, length.out = 8)^2
interval <- pmin(findInterval(x, breakpoints), length(breakpoints) - 1)
return(((interval %% 2) == 1) * 2 - 1)
}
# Example usage:
x <- seq(0, 1, length.out = 100)
plot(f(x) ~ x)
beta <- lapply(x, f)
f_bar <- mean(unlist(beta))
beta <- lapply(beta, function(b, adj) b - adj, f_bar)
plot(unlist(beta))
# Define the function using modular math
f <- function(x) {
breakpoints <- seq(0, 1, length.out = 9)^2
interval <- pmin(findInterval(x, breakpoints), length(breakpoints) - 1)
return(((interval %% 2) == 1) * 2 - 1)
}
# Example usage:
x <- seq(0, 1, length.out = 100)
plot(f(x) ~ x)
beta <- lapply(x, f)
f_bar <- mean(unlist(beta))
beta <- lapply(beta, function(b, adj) b - adj, f_bar)
plot(unlist(beta))
# Define the function using modular math
f <- function(x) {
breakpoints <- seq(0, 1, length.out = 9)^2
interval <- pmin(findInterval(x, breakpoints), length(breakpoints) - 1)
return(((interval %% 2) == 1) * 1)
}
# Example usage:
x <- seq(0, 1, length.out = 100)
plot(f(x) ~ x)
beta <- lapply(x, f)
f_bar <- mean(unlist(beta))
beta <- lapply(beta, function(b, adj) b - adj, f_bar)
plot(unlist(beta))
# Define the function using modular math
f <- function(x) {
ifelse(x <= 0.4, 2.5 * x,
ifelse(x <= 0.6, 45 * x - 17,
ifelse(x <= 0.8, -40 * x + 34,
30 * x - 22)))
}
# Example usage:
x <- seq(0, 1, length.out = 100)
plot(f(x) ~ x)
beta <- lapply(x, f)
f_bar <- mean(unlist(beta))
beta <- lapply(beta, function(b, adj) b - adj, f_bar)
plot(unlist(beta))
dotPlot?
?dotPlot
dotPlot
?dotplot
plot
?plot
?Plot
?dotPlot
?dotchart
X <- cbind(rep(1, 8),
rep(c(-1, 1), 4),
rep(c(-1, -1, 1, 1), 2),
c(rep(-1, 4), rep(1, 4)))
X
t(X) %*% X
inv(t(X) %*% X)
inverse(t(X) %*% X)
solve(t(X) %*% X)
solve(t(X) %*% X)%*%X
solve(t(X) %*% X) %*% t(X)
t(X)
X
X <- cbind(rep(1, 8),
rep(c(-1, 1), 4),
rep(c(-1, -1, 1, 1), 2),
c(rep(-1, 4), rep(1, 4)))
X
rbind(X, X[, 2]*X[, 3], X[, 2]*X[, 4], X[, 3]*X[, 4])
X[, 2]*X[, 3]
X
cbind(X, X[, 2]*X[, 3], X[, 2]*X[, 4], X[, 3]*X[, 4])
Xb <- cbind(X, X[, 2]*X[, 3], X[, 2]*X[, 4], X[, 3]*X[, 4])
Xb
solve(t(Xb) %*% Xb) %*% t(Xb)
solve(t(Xb) %*% Xb)
t(Xb)
Xd <- cbind(Xb, X[, 2]*X[, 3]*X[, 4])
Xd
solve(t(Xd) %*% Xd)
t(Xd)
library(rTensor)
source("SBS.R")
source("CUSUM.R")
setwd("~/Desktop/Research/MRDPG/CPDmrdpg")
library(rTensor)
source("SBS.R")
source("CUSUM.R")
source("eval.R")
source("model_selection.R")
run_sensitivity <- function(both = TRUE) {
confirm <- function(label) {
repeat {
ans <- readline(paste0("Did you check ", label, "? (y/n): "))
if (tolower(ans) == "y") break
if (tolower(ans) == "n") stop(paste("Please fix ", label, " before proceeding."))
cat("Please answer 'y' or 'n'.\n")
}
}
confirm("true_cp")
confirm("load files for 50 and 100")
confirm("save files for 50 and 100")
cat("All settings confirmed. Proceeding...\n")
# true_CP <- c(40, 60) # Sce 1
# true_CP <- c(50,100) # Sce 2, 5, 6, 6b
# true_CP <- c(50,100,150,200,250) # Sce 3
# true_CP <- c(20, 60, 80, 160, 180) #Sce 3b
# true_CP <- c() # Sce 4
true_CP <- c(20,50,80) # Sce 7
load("data/seq10n50s3b.RData") # Scenario 1 with node 50
num_seq <- dim(A.all_seq)[1] # 10 sequences
num_T <- dim(A.all_seq)[2] # 150 time points
num_node <- dim(A.all_seq)[3]
num_layer <- dim(A.all_seq)[5]
hat.rank <- c(15, 15, num_layer) # needed for model selection (Question: should be used as input to some FUNC)
# c(0.1, 0.2, 0.25, 0.3, 0.4)
level_list <- rev(c(0.05, 0.1, 0.2, 0.5) * num_node*sqrt(num_layer)*(log(num_T/2))^(3/2))
seq_iter <- 1 # used to test INSIDE the for-loop
intervals <- construct_intervals(num_T/2, sqrt(1/2), 4)
output_holder_s <- array(NA, dim = c(num_seq, length(level_list), 4))
output_holder_sl1 <- array(NA, dim = c(num_seq, length(level_list), 4))
output_holder_r <- array(NA, dim = c(num_seq, length(level_list), 4))
output_holder_rl1 <- array(NA, dim = c(num_seq, length(level_list), 4))
# report mean of metric for all simulated sequences
# can suppress print statements with verbose = FALSE (default TRUE)
for(seq_iter in 1:num_seq) {
cat("\nIteration", seq_iter, "begin.\n")
A.tensor <- A.all_seq[seq_iter,,,,] # a particular sequence with dim 150  50  50   4
# splitting data in half
A.tensor.even <- A.tensor[seq(2, num_T, by = 2), , , ]
B.tensor.odd  <- A.tensor[seq(1, num_T-1, by = 2), , , ] # named as B.tensor
gains <- cusum_on_intervals(CUSUM_step1, A.tensor.even, verbose = FALSE, intervals, obj.B = B.tensor.odd)
init <- seeded_binary_seg(CUSUM_step1, A.tensor.even, num_T/2, CUSUM_res = gains, verbose = FALSE,
threshold = 1, method = "Greedy", obj.B = B.tensor.odd)
for (i in 1:length(level_list)) {
detected_CP_s <- sort(steepest_drop(init[[2]]$results, level_list[i], verbose = FALSE)$candidates)
detected_CP_sl1 <- refinement1(detected_CP_s, A.tensor.even, B.tensor.odd, hat.rank)
detected_CP_r <- sort(steepest_drop_relative(init[[2]]$results, level_list[i], verbose = FALSE)$candidates)
detected_CP_rl1 <- refinement1(detected_CP_r, A.tensor.even, B.tensor.odd, hat.rank)
output_holder_s[seq_iter, i, ] <- as.numeric(eval_CP(true_CP, 2*detected_CP_s, num_T))
output_holder_sl1[seq_iter, i, ] <- as.numeric(eval_CP(true_CP, 2*detected_CP_sl1, num_T))
output_holder_r[seq_iter, i, ] <- as.numeric(eval_CP(true_CP, 2*detected_CP_r, num_T))
output_holder_rl1[seq_iter, i, ] <- as.numeric(eval_CP(true_CP, 2*detected_CP_rl1, num_T))
cat("Threshold: ", level_list[i], "\n")
cat("\tDetected SDLL CP :", 2*detected_CP_s, ". Metrics: ", output_holder_s[seq_iter, i, ], "\n")
cat("\tRefinement SDLL  :", 2*detected_CP_sl1, ". Metrics: ", output_holder_sl1[seq_iter, i, ], "\n")
cat("\tDetected Rel CP  :", 2*detected_CP_r, ". Metrics: ", output_holder_r[seq_iter, i, ], "\n")
cat("\tRefinement Rel   :", 2*detected_CP_rl1, ". Metrics: ", output_holder_rl1[seq_iter, i, ], "\n")
}
}
sce_50 <- list(
SDLL = output_holder_s,
SDLL1 = output_holder_sl1,
relSDLL = output_holder_r,
relSDLL1 = output_holder_rl1
)
save(sce_50, file = "results/S_sce3b_50.RData")
if(both == FALSE) {return ()}
load("data/seq10n100s7.RData")
num_seq <- dim(A.all_seq)[1] # 10 sequences
num_T <- dim(A.all_seq)[2] # 150 time points
num_node <- dim(A.all_seq)[3]
num_layer <- dim(A.all_seq)[5]
hat.rank <- c(15, 15, num_layer) # needed for model selection (Question: should be used as input to some FUNC)
# c(0.1, 0.2, 0.25, 0.3, 0.4)
level_list <- rev(c(0.05, 0.1, 0.2, 0.5) * num_node*sqrt(num_layer)*(log(num_T/2))^(3/2))
seq_iter <- 1 # used to test INSIDE the for-loop
intervals <- construct_intervals(num_T/2, sqrt(1/2), 4)
output_holder_s <- array(NA, dim = c(num_seq, length(level_list), 4))
output_holder_sl1 <- array(NA, dim = c(num_seq, length(level_list), 4))
output_holder_r <- array(NA, dim = c(num_seq, length(level_list), 4))
output_holder_rl1 <- array(NA, dim = c(num_seq, length(level_list), 4))
# report mean of metric for all simulated sequences
# can suppress print statements with verbose = FALSE (default TRUE)
for(seq_iter in 1:num_seq) {
cat("\nIteration", seq_iter, "begin.\n")
A.tensor <- A.all_seq[seq_iter,,,,] # a particular sequence with dim 150  50  50   4
# splitting data in half
A.tensor.even <- A.tensor[seq(2, num_T, by = 2), , , ]
B.tensor.odd  <- A.tensor[seq(1, num_T-1, by = 2), , , ] # named as B.tensor
gains <- cusum_on_intervals(CUSUM_step1, A.tensor.even, verbose = FALSE, intervals, obj.B = B.tensor.odd)
init <- seeded_binary_seg(CUSUM_step1, A.tensor.even, num_T/2, CUSUM_res = gains, verbose = FALSE,
threshold = 1, method = "Greedy", obj.B = B.tensor.odd)
for (i in 1:length(level_list)) {
detected_CP_s <- sort(steepest_drop(init[[2]]$results, level_list[i], verbose = FALSE)$candidates)
detected_CP_sl1 <- refinement1(detected_CP_s, A.tensor.even, B.tensor.odd, hat.rank)
detected_CP_r <- sort(steepest_drop_relative(init[[2]]$results, level_list[i], verbose = FALSE)$candidates)
detected_CP_rl1 <- refinement1(detected_CP_r, A.tensor.even, B.tensor.odd, hat.rank)
output_holder_s[seq_iter, i, ] <- as.numeric(eval_CP(true_CP, 2*detected_CP_s, num_T))
output_holder_sl1[seq_iter, i, ] <- as.numeric(eval_CP(true_CP, 2*detected_CP_sl1, num_T))
output_holder_r[seq_iter, i, ] <- as.numeric(eval_CP(true_CP, 2*detected_CP_r, num_T))
output_holder_rl1[seq_iter, i, ] <- as.numeric(eval_CP(true_CP, 2*detected_CP_rl1, num_T))
cat("Threshold: ", level_list[i], "\n")
cat("\tDetected SDLL CP :", 2*detected_CP_s, ". Metrics: ", output_holder_s[seq_iter, i, ], "\n")
cat("\tRefinement SDLL  :", 2*detected_CP_sl1, ". Metrics: ", output_holder_sl1[seq_iter, i, ], "\n")
cat("\tDetected Rel CP  :", 2*detected_CP_r, ". Metrics: ", output_holder_r[seq_iter, i, ], "\n")
cat("\tRefinement Rel   :", 2*detected_CP_rl1, ". Metrics: ", output_holder_rl1[seq_iter, i, ], "\n")
}
}
sce_100 <- list(
SDLL = output_holder_s,
SDLL1 = output_holder_sl1,
relSDLL = output_holder_r,
relSDLL1 = output_holder_rl1
)
save(sce_100, file = "results/S_sce7_100.RData")
}
run_sensitivity()
